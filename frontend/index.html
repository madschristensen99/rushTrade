<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PULSE — 60s Prediction Markets</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700;800&family=Outfit:wght@300;400;600;700;900&display=swap" rel="stylesheet">
<script type="module">
  // Import viem and wallet client
  import { createWalletClient, custom, formatEther, createPublicClient, http } from 'https://esm.sh/viem@2.7.15';
  
  // Define Monad Devnet chain
  const monadDevnet = {
    id: 41454,
    name: 'Monad Devnet',
    network: 'monad-devnet',
    nativeCurrency: {
      decimals: 18,
      name: 'Monad',
      symbol: 'MON',
    },
    rpcUrls: {
      default: {
        http: ['https://testnet.monad.xyz'],
      },
      public: {
        http: ['https://testnet.monad.xyz'],
      },
    },
    blockExplorers: {
      default: { name: 'Monad Explorer', url: 'https://explorer.testnet.monad.xyz' },
    },
    testnet: true,
  };
  
  window.viem = { createWalletClient, custom, formatEther, createPublicClient, http, monadDevnet };
</script>
<style>
  :root {
    --bg: #06070b;
    --surface: #0c0e16;
    --surface-2: #12151f;
    --border: #1a1e30;
    --text: #e2e5f0;
    --text-dim: #5e6488;
    --green: #00e87b;
    --green-dim: rgba(0, 232, 123, 0.12);
    --green-glow: rgba(0, 232, 123, 0.35);
    --red: #ff3b5c;
    --red-dim: rgba(255, 59, 92, 0.12);
    --accent: #7b61ff;
    --accent-dim: rgba(123, 97, 255, 0.14);
    --yellow: #ffd60a;
    --cyan: #00d4ff;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Outfit', sans-serif;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.025'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 9999;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 24px;
    border-bottom: 1px solid var(--border);
    background: rgba(6, 7, 11, 0.9);
    backdrop-filter: blur(16px);
    z-index: 50;
    flex-shrink: 0;
  }

  .header-left { display: flex; align-items: center; gap: 20px; }

  .logo { display: flex; align-items: center; gap: 9px; }

  .logo-icon {
    width: 30px; height: 30px;
    background: linear-gradient(135deg, var(--accent), var(--green));
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 14px; color: #000;
  }

  .logo-text {
    font-weight: 800; font-size: 18px; letter-spacing: 3px;
    background: linear-gradient(135deg, #fff, #8890b0);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }

  .asset-pill {
    display: flex; align-items: center; gap: 10px;
    padding: 6px 14px 6px 8px;
    background: var(--surface-2); border: 1px solid var(--border); border-radius: 10px;
  }

  .asset-icon {
    width: 28px; height: 28px; border-radius: 50%;
    background: linear-gradient(135deg, #f7931a, #ff9500);
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 13px; color: #fff;
  }

  .asset-name-sm { font-weight: 700; font-size: 14px; }
  .asset-pair-sm { color: var(--text-dim); font-size: 12px; }

  .price-live { display: flex; align-items: baseline; gap: 10px; }

  .current-price {
    font-family: 'JetBrains Mono', monospace;
    font-size: 22px; font-weight: 700; letter-spacing: -0.5px;
  }

  .price-change { font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; }
  .price-change.up { color: var(--green); }
  .price-change.down { color: var(--red); }

  .header-right { display: flex; align-items: center; gap: 16px; }

  .live-badge {
    display: flex; align-items: center; gap: 5px;
    font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--green);
    padding: 4px 10px; background: var(--green-dim); border-radius: 6px;
    border: 1px solid rgba(0, 232, 123, 0.2);
  }

  .live-dot {
    width: 6px; height: 6px; background: var(--green);
    border-radius: 50%; animation: blink 1s ease-in-out infinite;
  }

  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

  .wallet-btn {
    padding: 8px 18px; background: linear-gradient(135deg, var(--accent), #9b7dff);
    border: none; border-radius: 8px; color: #fff;
    font-family: 'Outfit', sans-serif; font-size: 13px; font-weight: 700;
    cursor: pointer; transition: all 0.2s;
    box-shadow: 0 0 20px rgba(123, 97, 255, 0.3);
  }
  
  .wallet-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 0 25px rgba(123, 97, 255, 0.5);
  }
  
  .wallet-btn:active { transform: translateY(0); }

  .balance-pill {
    display: flex; align-items: center; gap: 7px;
    padding: 6px 14px; background: var(--surface-2);
    border: 1px solid var(--border); border-radius: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600;
    cursor: pointer; transition: all 0.2s;
  }
  
  .balance-pill:hover {
    background: var(--surface);
    border-color: var(--accent);
  }

  .bal-icon {
    width: 7px; height: 7px; border-radius: 50%;
    background: var(--green); box-shadow: 0 0 6px var(--green-glow);
  }

  .main {
    flex: 1; display: grid;
    grid-template-columns: 1fr 320px;
    min-height: 0;
  }

  .chart-wrap {
    position: relative; min-height: 0;
    border-right: 1px solid var(--border);
  }

  .chart-wrap canvas { position: absolute; inset: 0; }

  .chart-toolbar {
    position: absolute; top: 12px; left: 14px;
    display: flex; gap: 6px; z-index: 10;
  }

  .tb-btn {
    padding: 5px 12px; border: 1px solid var(--border); border-radius: 7px;
    background: rgba(12, 14, 22, 0.85); backdrop-filter: blur(10px);
    color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
    font-size: 10px; cursor: pointer; transition: all 0.2s; user-select: none;
  }

  .tb-btn:hover { border-color: var(--accent); color: var(--text); }
  .tb-btn.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(123,97,255,0.4); }
  .tb-btn.danger:hover { border-color: var(--red); color: var(--red); }

  .profit-indicator {
    position: absolute; top: 12px; right: 14px; z-index: 10;
    padding: 6px 14px; border-radius: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 700;
    opacity: 0; transition: all 0.3s; pointer-events: none;
  }

  .profit-indicator.show-profit {
    opacity: 1; background: rgba(0,232,123,0.15); color: var(--green);
    border: 1px solid rgba(0,232,123,0.35);
    box-shadow: 0 0 24px rgba(0,232,123,0.15);
    animation: profitBounce 0.8s ease-in-out infinite;
  }

  .profit-indicator.show-waiting {
    opacity: 0.7; background: rgba(94,100,136,0.12);
    color: var(--text-dim); border: 1px solid var(--border);
  }

  @keyframes profitBounce { 0%,100%{transform:scale(1)} 50%{transform:scale(1.04)} }

  .grid-info {
    position: absolute; bottom: 14px; left: 14px;
    display: flex; gap: 6px; z-index: 10; pointer-events: none;
  }

  .gi-pill {
    padding: 5px 10px; border-radius: 6px;
    font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: 600;
    backdrop-filter: blur(12px); border: 1px solid;
  }

  .gi-cells { background: rgba(123,97,255,0.12); color: var(--accent); border-color: rgba(123,97,255,0.25); }
  .gi-mult { background: rgba(255,214,10,0.08); color: var(--yellow); border-color: rgba(255,214,10,0.2); }

  /* Sidebar */
  .sidebar {
    display: flex; flex-direction: column;
    background: var(--surface); overflow-y: auto;
  }

  .sidebar-section { padding: 16px 18px; border-bottom: 1px solid var(--border); }

  .section-title {
    font-size: 9px; text-transform: uppercase; letter-spacing: 2px;
    color: var(--text-dim); margin-bottom: 12px; font-weight: 600;
  }

  .timer-row { display: flex; align-items: center; gap: 14px; }

  .countdown-ring { position: relative; width: 72px; height: 72px; flex-shrink: 0; }

  .countdown-ring svg { transform: rotate(-90deg); width: 72px; height: 72px; }
  .countdown-ring .track { fill: none; stroke: var(--surface-2); stroke-width: 5; }

  .countdown-ring .progress {
    fill: none; stroke: var(--accent); stroke-width: 5; stroke-linecap: round;
    stroke-dasharray: 201; stroke-dashoffset: 0;
    transition: stroke-dashoffset 1s linear, stroke 0.5s;
    filter: drop-shadow(0 0 5px rgba(123,97,255,0.4));
  }

  .countdown-ring .progress.warning { stroke: var(--yellow); filter: drop-shadow(0 0 5px rgba(255,214,10,0.4)); }
  .countdown-ring .progress.danger { stroke: var(--red); filter: drop-shadow(0 0 5px rgba(255,59,92,0.4)); }

  .countdown-center {
    position: absolute; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  .countdown-time { font-family: 'JetBrains Mono', monospace; font-size: 24px; font-weight: 800; }
  .countdown-label { font-size: 7px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; }

  .round-meta { display: flex; flex-direction: column; gap: 3px; }
  .round-number { font-family: 'JetBrains Mono', monospace; font-size: 13px; color: var(--accent); font-weight: 700; }
  .round-status { font-size: 11px; color: var(--text-dim); }
  .round-open-price { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--text-dim); margin-top: 2px; }
  .round-open-price span { color: var(--text); font-weight: 600; }

  .how-steps { display: flex; flex-direction: column; gap: 7px; }

  .how-step { display: flex; gap: 9px; align-items: flex-start; }

  .how-num {
    width: 20px; height: 20px; border-radius: 5px;
    background: var(--accent-dim); color: var(--accent);
    font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }

  .how-text { font-size: 11.5px; color: var(--text-dim); line-height: 1.35; }
  .how-text b { color: var(--text); font-weight: 600; }

  .bet-section { display: flex; flex-direction: column; gap: 10px; }
  .bet-input-wrap { position: relative; }

  .bet-input-wrap .cur {
    position: absolute; left: 12px; top: 50%; transform: translateY(-50%);
    color: var(--text-dim); font-family: 'JetBrains Mono', monospace; font-size: 13px;
  }

  .bet-input {
    width: 100%; padding: 10px 10px 10px 24px;
    background: var(--bg); border: 1px solid var(--border); border-radius: 9px;
    color: var(--text); font-family: 'JetBrains Mono', monospace;
    font-size: 18px; font-weight: 700; outline: none; transition: border-color 0.2s;
  }

  .bet-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }

  .bet-presets { display: flex; gap: 4px; }

  .preset-btn {
    padding: 7px 0; flex: 1;
    border: 1px solid var(--border); border-radius: 6px;
    background: var(--bg); color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
    cursor: pointer; transition: all 0.2s;
  }

  .preset-btn:hover { border-color: var(--accent); color: var(--text); }

  .stats-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }

  .stat-card {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 7px; padding: 8px 6px; text-align: center;
  }

  .stat-card-label { font-size: 8px; text-transform: uppercase; letter-spacing: 0.7px; color: var(--text-dim); margin-bottom: 3px; }
  .stat-card-val { font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; }
  .sc-accent { color: var(--accent); }
  .sc-yellow { color: var(--yellow); }
  .sc-green { color: var(--green); }

  .place-btn {
    width: 100%; padding: 13px; border: none; border-radius: 11px;
    font-family: 'Outfit', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.5px; text-transform: uppercase; cursor: pointer;
    transition: all 0.3s; position: relative; overflow: hidden;
    background: linear-gradient(135deg, var(--accent), #9b7bff);
    color: #fff; box-shadow: 0 4px 18px rgba(123,97,255,0.3);
  }

  .place-btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 6px 24px rgba(123,97,255,0.4); }
  .place-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }
  .place-btn.locked { background: var(--surface-2); color: var(--text-dim); box-shadow: none; cursor: default; opacity: 1; }

  .place-btn.in-profit {
    background: linear-gradient(135deg, #00c766, var(--green));
    box-shadow: 0 0 24px var(--green-glow); color: #000; font-weight: 800; opacity: 1;
  }

  .place-btn::after {
    content: ''; position: absolute; inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent);
    transform: translateX(-100%); animation: shimmer 3s infinite;
  }

  @keyframes shimmer { 100% { transform: translateX(100%); } }

  .legend-row { display: flex; gap: 12px; padding-top: 6px; flex-wrap: wrap; }

  .legend-item {
    display: flex; align-items: center; gap: 4px;
    font-family: 'JetBrains Mono', monospace; font-size: 9px; color: var(--text-dim);
  }

  .legend-sw { width: 8px; height: 8px; border-radius: 2px; }

  .trade-log { display: flex; flex-direction: column; gap: 4px; }

  .trade-entry {
    display: flex; align-items: center; justify-content: space-between;
    padding: 7px 10px; background: var(--bg); border-radius: 6px;
    border: 1px solid var(--border);
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
    animation: fadeIn 0.3s ease;
  }

  .trade-id { color: var(--text-dim); }
  .tag-win { padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: 700; background: var(--green-dim); color: var(--green); }
  .tag-loss { padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: 700; background: var(--red-dim); color: var(--red); }
  .pnl-pos { color: var(--green); font-weight: 700; }
  .pnl-neg { color: var(--red); font-weight: 700; }

  .profit-flash {
    position: fixed; inset: 0; pointer-events: none; z-index: 9998;
    opacity: 0; transition: opacity 0.3s;
    background: radial-gradient(circle at 50% 50%, rgba(0,232,123,0.06), transparent 70%);
  }

  .profit-flash.active { opacity: 1; }

  @keyframes fadeIn { from { opacity:0; transform:translateY(-5px); } to { opacity:1; transform:translateY(0); } }

  @media (max-width: 900px) {
    .main { grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
    .chart-wrap { border-right: none; min-height: 350px; }
    .sidebar { max-height: 50vh; }
  }
</style>
</head>
<body>

<div class="profit-flash" id="profitFlash"></div>

<div class="header">
  <div class="header-left">
    <div class="logo"><div class="logo-icon">P</div><div class="logo-text">PULSE</div></div>
    <div class="asset-pill">
      <div class="asset-icon">₿</div>
      <span class="asset-name-sm">BTC <span class="asset-pair-sm">/ USDT</span></span>
    </div>
    <div class="price-live">
      <span class="current-price" id="currentPrice">$97,241.38</span>
      <span class="price-change up" id="priceChange">+0.42%</span>
    </div>
  </div>
  <div class="header-right">
    <div class="live-badge"><span class="live-dot"></span> LIVE</div>
    <button class="wallet-btn" id="walletBtn" style="display: none;">Connect Wallet</button>
    <div class="balance-pill" id="balancePill" style="display: none;"><span class="bal-icon"></span> <span id="balance">$1,000.00</span></div>
  </div>
</div>

<div class="main">
  <div class="chart-wrap" id="chartWrap">
    <canvas id="mainCanvas"></canvas>
    <div class="chart-toolbar">
      <button class="tb-btn active" id="btnPaint">✦ Paint</button>
      <button class="tb-btn" id="btnErase">✕ Erase</button>
      <button class="tb-btn danger" id="btnClear">Clear All</button>
    </div>
    <div class="profit-indicator" id="profitInd"></div>
    <div class="grid-info">
      <div class="gi-pill gi-cells" id="giCells">0 cells</div>
      <div class="gi-pill gi-mult" id="giMult">—</div>
    </div>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <div class="section-title">Round</div>
      <div class="timer-row">
        <div class="countdown-ring">
          <svg viewBox="0 0 72 72">
            <circle class="track" cx="36" cy="36" r="32"/>
            <circle class="progress" id="timerProgress" cx="36" cy="36" r="32"/>
          </svg>
          <div class="countdown-center">
            <div class="countdown-time" id="countdownTime">60</div>
            <div class="countdown-label">sec</div>
          </div>
        </div>
        <div class="round-meta">
          <div class="round-number" id="roundNumber">#12,848</div>
          <div class="round-status" id="roundStatus">Accepting bets</div>
          <div class="round-open-price">Open: <span id="openPrice">$97,241</span></div>
        </div>
      </div>
    </div>

    <div class="sidebar-section">
      <div class="section-title">How to Play</div>
      <div class="how-steps">
        <div class="how-step"><div class="how-num">1</div><div class="how-text"><b>Paint zones</b> on the chart grid where you predict price will go</div></div>
        <div class="how-step"><div class="how-num">2</div><div class="how-text"><b>Fewer cells = bigger payout.</b> A 3s buffer keeps it fair — no painting the present</div></div>
        <div class="how-step"><div class="how-num">3</div><div class="how-text">When the <b>price cursor</b> hits your zone, you're <b style="color:var(--green)">in profit</b></div></div>
      </div>
    </div>

    <div class="sidebar-section">
      <div class="section-title">Stake</div>
      <div class="bet-section">
        <div class="bet-input-wrap">
          <span class="cur">$</span>
          <input type="number" class="bet-input" id="betInput" value="50" min="1">
        </div>
        <div class="bet-presets">
          <button class="preset-btn" onclick="setBet(10)">$10</button>
          <button class="preset-btn" onclick="setBet(25)">$25</button>
          <button class="preset-btn" onclick="setBet(50)">$50</button>
          <button class="preset-btn" onclick="setBet(100)">$100</button>
        </div>
        <div class="stats-row">
          <div class="stat-card"><div class="stat-card-label">Cells</div><div class="stat-card-val sc-accent" id="dCells">0</div></div>
          <div class="stat-card"><div class="stat-card-label">Multi</div><div class="stat-card-val sc-yellow" id="dMult">—</div></div>
          <div class="stat-card"><div class="stat-card-label">Payout</div><div class="stat-card-val sc-green" id="dPay">—</div></div>
        </div>
        <button class="place-btn" id="placeBtn" disabled>Select zones on chart</button>
        <div class="legend-row">
          <div class="legend-item"><div class="legend-sw" style="background:rgba(123,97,255,0.55)"></div>Your Zone</div>
          <div class="legend-item"><div class="legend-sw" style="background:rgba(0,232,123,0.65)"></div>In Profit</div>
          <div class="legend-item"><div class="legend-sw" style="background:rgba(0,212,255,0.6)"></div>Price</div>
          <div class="legend-item"><div class="legend-sw" style="background:repeating-linear-gradient(45deg,#ff3b5c22,#ff3b5c22 2px,transparent 2px,transparent 4px)"></div>Locked</div>
        </div>
      </div>
    </div>

    <div class="sidebar-section" style="border-bottom:none;flex:1;">
      <div class="section-title">Trade Log</div>
      <div class="trade-log" id="tradeLog"></div>
    </div>
  </div>
</div>

<script>
// ===== CONFIG =====
const GRID_COLS = 12;
const GRID_ROWS = 24;
const TOTAL_CELLS = GRID_COLS * GRID_ROWS;
const CIRC = 2 * Math.PI * 32;
const GRID_ZONE_RATIO = 0.55;
const CHART_PAD_TOP = 10;
const CHART_PAD_BOTTOM = 10;
const PRICE_LABEL_WIDTH = 58;
const BUFFER_SECONDS = 3; // 3-second no-bet buffer

// Each grid column spans this many seconds
const SECS_PER_COL = 60 / GRID_COLS; // 5s per column

// ===== WALLET STATE =====
let walletClient = null;
let publicClient = null;
let walletAddress = null;
let walletBalance = null;

// ===== STATE =====
let basePrice = 97241.38;
let currentPrice = basePrice;
let openPrice = basePrice;
let priceHistory = [];
let timeLeft = 57; // Match the 3-second offset
let roundNum = 12848;
let balanceVal = 1000;
let selectedCells = new Set();
let isMouseDown = false;
let toolMode = 'paint';
let betLocked = false;
let lockedCells = new Set();
let lockedBet = 0;
let hitCells = new Set(); // Track cells that have been successfully hit
let inProfit = false;
let prevInProfit = false;
let profitTicks = 0;
let gridPriceHigh, gridPriceLow;
// Start 3 seconds into the round for better initial appearance
let roundStartTime = Date.now() - 3000;

// Start with just current price, no history
priceHistory.push(basePrice);
currentPrice = priceHistory[priceHistory.length - 1];
openPrice = currentPrice;
gridPriceHigh = currentPrice + 300;
gridPriceLow = currentPrice - 300;

// ===== CANVAS =====
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  const r = canvas.parentElement.getBoundingClientRect();
  canvas.width = r.width * devicePixelRatio;
  canvas.height = r.height * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  canvas.style.width = r.width + 'px';
  canvas.style.height = r.height + 'px';
}

// Returns the first column index that is open for betting
function getFirstBettableCol() {
  const elapsed = 60 - timeLeft;
  const bufferEnd = elapsed + BUFFER_SECONDS;
  // First column whose START time is >= bufferEnd
  const col = Math.ceil(bufferEnd / SECS_PER_COL);
  return Math.min(col, GRID_COLS); // can be GRID_COLS meaning nothing is bettable
}

function isCellLocked(col) {
  return col < getFirstBettableCol();
}

// Auto-remove selected cells that have become locked
function pruneLockedSelections() {
  if (betLocked) return; // don't touch locked bets
  const firstOpen = getFirstBettableCol();
  let changed = false;
  for (const key of selectedCells) {
    const c = parseInt(key.split('-')[1]);
    if (c < firstOpen) {
      selectedCells.delete(key);
      changed = true;
    }
  }
  if (changed) updateBetUI();
}

function draw() {
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;
  ctx.clearRect(0, 0, W, H);

  const chartH = H - CHART_PAD_TOP - CHART_PAD_BOTTOM;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;
  const gridW = gridEndX - gridStartX;
  const gridY = CHART_PAD_TOP;
  const cellW = gridW / GRID_COLS;
  const cellH = chartH / GRID_ROWS;
  const priceRange = gridPriceHigh - gridPriceLow;
  const toY = v => CHART_PAD_TOP + (1 - (v - gridPriceLow) / priceRange) * chartH;

  // Current position on grid with sub-second precision
  const elapsedMs = Date.now() - roundStartTime;
  const elapsedSec = Math.min(60, elapsedMs / 1000);
  // Fractional column for smooth cursor (based on elapsed + sub-second from price ticks)
  const tColFrac = elapsedSec / SECS_PER_COL;
  const tColC = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(tColFrac)));
  const pRow = Math.floor((1 - (currentPrice - gridPriceLow) / priceRange) * GRID_ROWS);
  const pRowC = Math.max(0, Math.min(GRID_ROWS - 1, pRow));

  const cells = betLocked ? lockedCells : selectedCells;
  const cursorKey = `${pRowC}-${tColC}`;
  const nowInProfit = betLocked && cells.has(cursorKey);

  const firstBettable = getFirstBettableCol();

  // ===== GRID ZONE BACKGROUND =====
  ctx.fillStyle = 'rgba(123, 97, 255, 0.012)';
  ctx.fillRect(gridStartX, gridY, gridW, chartH);

  // Separator
  ctx.setLineDash([4, 4]);
  ctx.strokeStyle = 'rgba(123, 97, 255, 0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(gridStartX, 0); ctx.lineTo(gridStartX, H); ctx.stroke();
  ctx.setLineDash([]);

  // ===== LOCKED ZONE (past + buffer) =====
  if (firstBettable > 0) {
    const lockedW = firstBettable * cellW;

    // Dark overlay
    ctx.fillStyle = 'rgba(6, 7, 11, 0.55)';
    ctx.fillRect(gridStartX, gridY, lockedW, chartH);

    // Diagonal hatch pattern
    ctx.save();
    ctx.beginPath();
    ctx.rect(gridStartX, gridY, lockedW, chartH);
    ctx.clip();
    ctx.strokeStyle = 'rgba(255, 59, 92, 0.08)';
    ctx.lineWidth = 1;
    const step = 8;
    for (let i = -chartH; i < lockedW + chartH; i += step) {
      ctx.beginPath();
      ctx.moveTo(gridStartX + i, gridY);
      ctx.lineTo(gridStartX + i + chartH, gridY + chartH);
      ctx.stroke();
    }
    ctx.restore();

    // Buffer boundary line
    const bufferX = gridStartX + lockedW;
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(255, 59, 92, 0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(bufferX, gridY); ctx.lineTo(bufferX, gridY + chartH); ctx.stroke();
    ctx.setLineDash([]);

    // "LOCKED" label
    if (lockedW > 40) {
      ctx.save();
      ctx.font = '600 8px JetBrains Mono';
      ctx.fillStyle = 'rgba(255, 59, 92, 0.3)';
      ctx.textAlign = 'center';
      ctx.fillText('LOCKED', gridStartX + lockedW / 2, gridY + 14);
      ctx.restore();
    }
  }

  // ===== DRAW GRID CELLS =====
  // Pulsing animation for unlocked selected cells
  const pulseTime = Date.now() / 1000;
  const pulseValue = Math.sin(pulseTime * 2.5) * 0.5 + 0.5; // Oscillates between 0 and 1
  
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      const key = `${r}-${c}`;
      const x = gridStartX + c * cellW;
      const y = gridY + r * cellH;
      const selected = cells.has(key);
      const locked = isCellLocked(c);
      const isCursor = (r === pRowC && c === tColC);
      const isHit = selected && isCursor && betLocked;
      const wasHit = hitCells.has(key); // Check if this cell was previously hit

      if (isHit || wasHit) {
        // Cell is currently being hit OR was hit before - keep it green
        ctx.fillStyle = 'rgba(0, 232, 123, 0.4)';
        ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        ctx.strokeStyle = '#00e87b';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
      } else if (selected && !locked) {
        if (betLocked) {
          // Bet is locked but cell hasn't been hit yet - dim it
          ctx.fillStyle = 'rgba(123,97,255,0.2)';
          ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
          ctx.strokeStyle = 'rgba(123,97,255,0.45)';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        } else {
          // Bet NOT locked - PULSE the selected cells
          const fillAlpha = 0.25 + pulseValue * 0.15; // Pulse between 0.25 and 0.4
          const strokeAlpha = 0.35 + pulseValue * 0.25; // Pulse between 0.35 and 0.6
          ctx.fillStyle = `rgba(123,97,255,${fillAlpha})`;
          ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
          ctx.strokeStyle = `rgba(123,97,255,${strokeAlpha})`;
          ctx.lineWidth = 0.5 + pulseValue * 0.5; // Pulse line width between 0.5 and 1
          ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        }
      } else if (selected && locked && betLocked) {
        // Locked bet cell that's been passed — dim it out
        ctx.fillStyle = 'rgba(123,97,255,0.08)';
        ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        ctx.strokeStyle = 'rgba(123,97,255,0.15)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
      }
    }
  }

  // Grid lines
  ctx.strokeStyle = 'rgba(30, 34, 53, 0.3)';
  ctx.lineWidth = 0.5;
  for (let r = 0; r <= GRID_ROWS; r++) {
    const y = gridY + r * cellH;
    ctx.beginPath(); ctx.moveTo(gridStartX, y); ctx.lineTo(gridEndX, y); ctx.stroke();
  }
  for (let c = 0; c <= GRID_COLS; c++) {
    const x = gridStartX + c * cellW;
    ctx.beginPath(); ctx.moveTo(x, gridY); ctx.lineTo(x, gridY + chartH); ctx.stroke();
  }

  // ===== PRICE CHART =====
  const data = priceHistory.slice(-100);
  if (data.length >= 2) {
    const chartEndX = gridStartX + gridW * 0.15;
    const chartStartX = 10;
    const cW = chartEndX - chartStartX;
    const toChartX = i => chartStartX + (i / (data.length - 1)) * cW;

    const last = data[data.length - 1];
    const first = data[0];
    const isUp = last >= first;
    const col = isUp ? '#00e87b' : '#ff3b5c';

    // Area
    const grad = ctx.createLinearGradient(0, CHART_PAD_TOP, 0, H);
    grad.addColorStop(0, isUp ? 'rgba(0,232,123,0.08)' : 'rgba(255,59,92,0.08)');
    grad.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.moveTo(toChartX(0), H);
    for (let i = 0; i < data.length; i++) {
      const x = toChartX(i), y = toY(data[i]);
      if (i === 0) ctx.lineTo(x, y);
      else { const px = toChartX(i-1), cp = (px+x)/2; ctx.bezierCurveTo(cp, toY(data[i-1]), cp, y, x, y); }
    }
    ctx.lineTo(toChartX(data.length - 1), H);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();

    // Line
    ctx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = toChartX(i), y = toY(data[i]);
      if (i === 0) ctx.moveTo(x, y);
      else { const px = toChartX(i-1), cp = (px+x)/2; ctx.bezierCurveTo(cp, toY(data[i-1]), cp, y, x, y); }
    }
    ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.stroke();
    ctx.strokeStyle = isUp ? 'rgba(0,232,123,0.15)' : 'rgba(255,59,92,0.15)'; ctx.lineWidth = 6; ctx.stroke();

    // Dot
    const dotX = toChartX(data.length - 1), dotY = toY(last);
    ctx.beginPath(); ctx.arc(dotX, dotY, 4, 0, Math.PI*2); ctx.fillStyle = col; ctx.fill();
    ctx.beginPath(); ctx.arc(dotX, dotY, 9, 0, Math.PI*2); ctx.fillStyle = isUp ? 'rgba(0,232,123,0.12)' : 'rgba(255,59,92,0.12)'; ctx.fill();

    // Dashed line across
    ctx.setLineDash([4,4]);
    ctx.strokeStyle = 'rgba(0,212,255,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(W, dotY); ctx.stroke();
    ctx.setLineDash([]);
  }

  // ===== PRICE CURSOR ON GRID =====
  const priceY = toY(currentPrice);
  // Blue dot position aligned with grid cells
  const timeXSnapped = gridStartX + (tColC + 0.5) * cellW;

  // Crosshairs
  ctx.setLineDash([5,3]);
  ctx.strokeStyle = 'rgba(0,212,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(gridStartX, priceY); ctx.lineTo(gridEndX, priceY); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,214,10,0.18)';
  ctx.beginPath(); ctx.moveTo(timeXSnapped, gridY); ctx.lineTo(timeXSnapped, gridY + chartH); ctx.stroke();
  ctx.setLineDash([]);

  // Cursor dot
  const dotColor = nowInProfit ? '#00e87b' : '#00d4ff';
  ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 5, 0, Math.PI*2); ctx.fillStyle = dotColor; ctx.fill();
  ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 11, 0, Math.PI*2);
  ctx.fillStyle = nowInProfit ? 'rgba(0,232,123,0.18)' : 'rgba(0,212,255,0.1)'; ctx.fill();

  if (nowInProfit) {
    ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 18, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,232,123,0.06)'; ctx.fill();
  }

  // ===== LABELS =====
  ctx.font = '10px JetBrains Mono';
  ctx.textAlign = 'right';
  ctx.fillStyle = '#4a5070';
  const labelStep = Math.max(1, Math.floor(GRID_ROWS / 6));
  for (let r = 0; r <= GRID_ROWS; r += labelStep) {
    const y = gridY + r * cellH;
    const pv = gridPriceHigh - (r / GRID_ROWS) * priceRange;
    ctx.fillText('$' + pv.toFixed(0), W - 6, y + 3);
  }

  // Current price tag
  ctx.fillStyle = nowInProfit ? '#00e87b' : '#00d4ff';
  const priceTag = '$' + currentPrice.toFixed(0);
  const tagW = ctx.measureText(priceTag).width + 14;
  const tagH = 20;
  const tagX = W - PRICE_LABEL_WIDTH + 4;
  const tagYPos = priceY - tagH / 2;
  ctx.beginPath(); ctx.roundRect(tagX, tagYPos, tagW, tagH, 4); ctx.fill();
  ctx.fillStyle = '#000'; ctx.font = 'bold 10px JetBrains Mono'; ctx.textAlign = 'left';
  ctx.fillText(priceTag, tagX + 7, priceY + 3.5);

  // Time labels
  ctx.textAlign = 'center'; ctx.fillStyle = '#3a3f5a'; ctx.font = '9px JetBrains Mono';
  for (let c = 0; c < GRID_COLS; c += 2) {
    const sec = Math.round(c * SECS_PER_COL);
    ctx.fillText(sec + 's', gridStartX + c * cellW + cellW / 2, H - 2);
  }

  // Zone label
  ctx.save();
  ctx.font = '600 9px Outfit';
  ctx.fillStyle = 'rgba(123,97,255,0.2)';
  ctx.textAlign = 'center';
  const openZoneCenter = gridStartX + (firstBettable * cellW + gridW) / 2;
  if (firstBettable < GRID_COLS) {
    ctx.fillText('P R E D I C T I O N   Z O N E', openZoneCenter, gridY + 14);
  }
  ctx.restore();

  // Horizontal chart gridlines (left of grid)
  ctx.strokeStyle = 'rgba(30,34,53,0.2)'; ctx.lineWidth = 0.5;
  for (let r = 0; r <= GRID_ROWS; r += labelStep) {
    const y = gridY + r * cellH;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(gridStartX, y); ctx.stroke();
  }

  // ===== PROFIT STATE =====
  if (nowInProfit && !prevInProfit) {
    document.getElementById('profitFlash').classList.add('active');
    setTimeout(() => document.getElementById('profitFlash').classList.remove('active'), 500);
  }
  if (nowInProfit) {
    profitTicks++;
    // Track this cell as a hit so it stays green
    hitCells.add(cursorKey);
  }
  inProfit = nowInProfit;
  prevInProfit = nowInProfit;

  const pInd = document.getElementById('profitInd');
  if (betLocked) {
    if (inProfit) {
      pInd.className = 'profit-indicator show-profit';
      pInd.textContent = '● IN PROFIT +$' + (lockedBet * getMult(lockedCells.size) - lockedBet).toFixed(0);
    } else {
      pInd.className = 'profit-indicator show-waiting';
      pInd.textContent = '⏳ Waiting...';
    }
  } else {
    pInd.className = 'profit-indicator';
  }

  const btn = document.getElementById('placeBtn');
  if (betLocked) {
    if (inProfit) {
      btn.className = 'place-btn in-profit';
      btn.textContent = '● IN PROFIT — $' + (lockedBet * getMult(lockedCells.size)).toFixed(0);
    } else {
      btn.className = 'place-btn locked';
      btn.textContent = '⏳ Waiting for price...';
    }
  }

  document.getElementById('giCells').textContent = cells.size + ' cells';
  const m = getMult(cells.size);
  document.getElementById('giMult').textContent = cells.size > 0 ? (m.toFixed(1) + 'x') : '—';
}

// ===== GRID INTERACTION =====
function getGridCell(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
  const my = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
  const W = rect.width;
  const H = rect.height;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;
  const gridW = gridEndX - gridStartX;
  const chartH = H - CHART_PAD_TOP - CHART_PAD_BOTTOM;

  if (mx < gridStartX || mx > gridEndX || my < CHART_PAD_TOP || my > CHART_PAD_TOP + chartH) return null;

  const col = Math.floor((mx - gridStartX) / (gridW / GRID_COLS));
  const row = Math.floor((my - CHART_PAD_TOP) / (chartH / GRID_ROWS));
  if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) return null;

  // Enforce buffer: can't paint locked columns
  if (isCellLocked(col)) return null;

  return `${row}-${col}`;
}

function onStart(e) {
  if (betLocked) return;
  const key = getGridCell(e);
  if (!key) return;
  isMouseDown = true;
  if (toolMode === 'paint') selectedCells.add(key);
  else selectedCells.delete(key);
  updateBetUI(); draw();
}

function onMove(e) {
  if (!isMouseDown || betLocked) return;
  const key = getGridCell(e);
  if (!key) return;
  if (toolMode === 'paint') selectedCells.add(key);
  else selectedCells.delete(key);
  updateBetUI(); draw();
}

function onEnd() { isMouseDown = false; }

canvas.addEventListener('mousedown', onStart);
canvas.addEventListener('mousemove', onMove);
document.addEventListener('mouseup', onEnd);
canvas.addEventListener('touchstart', e => { e.preventDefault(); onStart(e); }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e); }, { passive: false });
canvas.addEventListener('touchend', onEnd);

// Cursor style: crosshair in grid zone, default outside
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const W = rect.width;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;

  if (mx >= gridStartX && mx <= gridEndX) {
    const col = Math.floor((mx - gridStartX) / ((gridEndX - gridStartX) / GRID_COLS));
    canvas.style.cursor = isCellLocked(col) ? 'not-allowed' : 'crosshair';
  } else {
    canvas.style.cursor = 'default';
  }
});

document.getElementById('btnPaint').addEventListener('click', function() {
  toolMode = 'paint';
  this.classList.add('active');
  document.getElementById('btnErase').classList.remove('active');
});

document.getElementById('btnErase').addEventListener('click', function() {
  toolMode = 'erase';
  this.classList.add('active');
  document.getElementById('btnPaint').classList.remove('active');
});

document.getElementById('btnClear').addEventListener('click', () => {
  if (betLocked) return;
  selectedCells.clear();
  updateBetUI(); draw();
});

// ===== BET LOGIC =====
function getMult(n) {
  if (n === 0) return 0;
  return Math.max(1.1, (TOTAL_CELLS / n) * 0.55);
}

function updateBetUI() {
  const cnt = selectedCells.size;
  const bet = parseFloat(document.getElementById('betInput').value) || 0;
  const m = getMult(cnt);
  document.getElementById('dCells').textContent = cnt;
  document.getElementById('dMult').textContent = cnt > 0 ? m.toFixed(1) + 'x' : '—';
  document.getElementById('dPay').textContent = cnt > 0 ? '$' + (bet * m).toFixed(0) : '—';

  const btn = document.getElementById('placeBtn');
  if (!betLocked) {
    if (cnt > 0 && bet > 0) {
      btn.disabled = false;
      btn.textContent = `Lock Prediction — $${bet}`;
    } else {
      btn.disabled = true;
      btn.textContent = 'Select zones on chart';
    }
  }
}

document.getElementById('betInput').addEventListener('input', updateBetUI);
function setBet(v) { document.getElementById('betInput').value = v; updateBetUI(); }

document.getElementById('placeBtn').addEventListener('click', function() {
  if (betLocked || selectedCells.size === 0) return;
  betLocked = true;
  lockedCells = new Set(selectedCells);
  lockedBet = parseFloat(document.getElementById('betInput').value) || 0;
  profitTicks = 0;
  this.className = 'place-btn locked';
  this.textContent = '⏳ Waiting for price...';
  draw();
});

// ===== PRICE ENGINE =====
function tick() {
  const vol = 5 + Math.random() * 10;
  currentPrice += (Math.random() - 0.497) * vol;
  priceHistory.push(currentPrice);
  if (priceHistory.length > 250) priceHistory.shift();

  const gc = (gridPriceHigh + gridPriceLow) / 2;
  const d = (currentPrice - gc) * 0.04;
  gridPriceHigh += d; gridPriceLow += d;

  document.getElementById('currentPrice').textContent = '$' + currentPrice.toFixed(2);
  const chg = ((currentPrice - openPrice) / openPrice * 100);
  const ce = document.getElementById('priceChange');
  ce.textContent = (chg >= 0 ? '+' : '') + chg.toFixed(2) + '%';
  ce.className = 'price-change ' + (chg >= 0 ? 'up' : 'down');

  // Prune cells that have become locked (past + buffer)
  pruneLockedSelections();

  draw();
}

// ===== TIMER =====
function timerTick() {
  timeLeft--;
  if (timeLeft < 0) { resolveRound(); return; }
  document.getElementById('countdownTime').textContent = timeLeft;
  const p = document.getElementById('timerProgress');
  p.style.strokeDasharray = CIRC;
  p.style.strokeDashoffset = CIRC * (1 - timeLeft / 60);
  p.classList.remove('warning', 'danger');
  if (timeLeft <= 10) p.classList.add('danger');
  else if (timeLeft <= 20) p.classList.add('warning');
  if (timeLeft <= 10) {
    document.getElementById('roundStatus').textContent = 'Closing soon!';
    document.getElementById('roundStatus').style.color = '#ff3b5c';
  }
}

function resolveRound() {
  if (betLocked) {
    const m = getMult(lockedCells.size);
    const payout = lockedBet * m;
    if (profitTicks > 0) {
      balanceVal += payout - lockedBet;
      addTrade(roundNum, true, payout - lockedBet);
    } else {
      balanceVal -= lockedBet;
      addTrade(roundNum, false, -lockedBet);
    }
    document.getElementById('balance').textContent = '$' + balanceVal.toFixed(2);
  }

  betLocked = false; lockedCells.clear(); selectedCells.clear(); hitCells.clear();
  inProfit = false; prevInProfit = false; profitTicks = 0;
  roundNum++; timeLeft = 60;
  roundStartTime = Date.now();
  openPrice = currentPrice;
  gridPriceHigh = currentPrice + 300;
  gridPriceLow = currentPrice - 300;
  
  // Clear price history to sync with new round, keep last 2 points for continuity
  priceHistory = priceHistory.slice(-2);

  document.getElementById('roundNumber').textContent = '#' + roundNum.toLocaleString();
  document.getElementById('roundStatus').textContent = 'Accepting bets';
  document.getElementById('roundStatus').style.color = '';
  document.getElementById('openPrice').textContent = '$' + openPrice.toFixed(0);
  document.getElementById('timerProgress').classList.remove('warning', 'danger');
  updateBetUI(); draw();
}

function addTrade(id, won, pnl) {
  const c = document.getElementById('tradeLog');
  const d = document.createElement('div');
  d.className = 'trade-entry';
  d.innerHTML = `<span class="trade-id">#${id.toLocaleString()}</span><span class="${won?'tag-win':'tag-loss'}">${won?'WIN':'LOSS'}</span><span class="${won?'pnl-pos':'pnl-neg'}">${pnl>=0?'+':''}$${pnl.toFixed(0)}</span>`;
  c.insertBefore(d, c.firstChild);
  if (c.children.length > 8) c.removeChild(c.lastChild);
}

// ===== WALLET FUNCTIONS =====
async function connectWallet() {
  try {
    if (!window.ethereum) {
      alert('Please install MetaMask to use this app!');
      return;
    }

    // Wait for viem to load
    if (!window.viem) {
      console.log('Waiting for viem to load...');
      setTimeout(connectWallet, 100);
      return;
    }

    const { createWalletClient, custom, formatEther, createPublicClient, http, monadDevnet } = window.viem;

    // Request account access
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    walletAddress = accounts[0];

    // Create wallet client
    walletClient = createWalletClient({
      chain: monadDevnet,
      transport: custom(window.ethereum)
    });

    // Create public client for reading
    publicClient = createPublicClient({
      chain: monadDevnet,
      transport: http()
    });

    // Get balance
    await updateWalletBalance();

    // Update UI
    updateWalletUI();

    // Listen for account changes
    window.ethereum.on('accountsChanged', handleAccountsChanged);
    window.ethereum.on('chainChanged', () => window.location.reload());

  } catch (error) {
    console.error('Error connecting wallet:', error);
    alert('Failed to connect wallet. Please try again.');
  }
}

async function updateWalletBalance() {
  if (!walletAddress || !window.viem) return;
  
  try {
    const { formatEther } = window.viem;
    const balance = await window.ethereum.request({
      method: 'eth_getBalance',
      params: [walletAddress, 'latest']
    });
    
    // Convert hex to decimal and format
    const balanceInEth = formatEther(BigInt(balance));
    walletBalance = parseFloat(balanceInEth).toFixed(4);
    updateWalletUI();
  } catch (error) {
    console.error('Error fetching balance:', error);
  }
}

function updateWalletUI() {
  const walletBtn = document.getElementById('walletBtn');
  const balancePill = document.getElementById('balancePill');
  const balanceText = document.getElementById('balance');

  if (walletAddress) {
    // Show balance pill, hide connect button
    walletBtn.style.display = 'none';
    balancePill.style.display = 'flex';
    
    // Format address: 0x1234...5678
    const shortAddress = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
    balanceText.textContent = `${shortAddress} • ${walletBalance || '0.0000'} MON`;
  } else {
    // Show connect button, hide balance pill
    walletBtn.style.display = 'block';
    balancePill.style.display = 'none';
  }
}

function handleAccountsChanged(accounts) {
  if (accounts.length === 0) {
    // User disconnected wallet
    walletAddress = null;
    walletBalance = null;
    walletClient = null;
    publicClient = null;
    updateWalletUI();
  } else {
    // User switched accounts
    walletAddress = accounts[0];
    updateWalletBalance();
  }
}

function disconnectWallet() {
  walletAddress = null;
  walletBalance = null;
  walletClient = null;
  publicClient = null;
  updateWalletUI();
}

// ===== ANIMATION LOOP =====
function animate() {
  draw();
  requestAnimationFrame(animate);
}

// ===== INIT =====
resize(); draw(); updateBetUI();
document.getElementById('openPrice').textContent = '$' + openPrice.toFixed(0);
window.addEventListener('resize', () => { resize(); draw(); });
setInterval(tick, 350);
setInterval(timerTick, 1000);

// Start continuous animation loop for smooth pulsing
requestAnimationFrame(animate);

// Wallet button event listeners
document.getElementById('walletBtn').addEventListener('click', connectWallet);
document.getElementById('balancePill').addEventListener('click', disconnectWallet);

// Show connect button on load
updateWalletUI();
</script>
</body>
</html>
