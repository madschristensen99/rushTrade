<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RushTrade â€” 60s Prediction Markets</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700;800&family=Outfit:wght@300;400;600;700;900&display=swap" rel="stylesheet">
<script type="module">
  // Import viem and wallet client
  import { createWalletClient, custom, formatEther, createPublicClient, http } from 'https://esm.sh/viem@2.7.15';
  
  // Define Monad Testnet chain
  const monadTestnet = {
    id: 10143,
    name: 'Monad Testnet',
    network: 'monad-testnet',
    nativeCurrency: {
      decimals: 18,
      name: 'Monad',
      symbol: 'MON',
    },
    rpcUrls: {
      default: {
        http: ['https://testnet-rpc.monad.xyz'],
      },
      public: {
        http: ['https://testnet-rpc.monad.xyz'],
      },
    },
    blockExplorers: {
      default: { name: 'MonadScan', url: 'https://testnet.monadscan.com' },
    },
    testnet: true,
  };
  
  window.viem = { createWalletClient, custom, formatEther, createPublicClient, http, monadTestnet };
  window.pythReady = true;
</script>
<style>
  :root {
    --bg: #06070b;
    --surface: #0c0e16;
    --surface-2: #12151f;
    --border: #1a1e30;
    --text: #e2e5f0;
    --text-dim: #5e6488;
    --green: #00e87b;
    --green-dim: rgba(0, 232, 123, 0.12);
    --green-glow: rgba(0, 232, 123, 0.35);
    --red: #ff3b5c;
    --red-dim: rgba(255, 59, 92, 0.12);
    --accent: #7b61ff;
    --accent-dim: rgba(123, 97, 255, 0.14);
    --yellow: #ffd60a;
    --cyan: #00d4ff;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Outfit', sans-serif;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.025'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 9999;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 24px;
    border-bottom: 1px solid var(--border);
    background: rgba(6, 7, 11, 0.9);
    backdrop-filter: blur(16px);
    z-index: 50;
    flex-shrink: 0;
  }

  .header-left { display: flex; align-items: center; gap: 20px; }

  .logo { display: flex; align-items: center; gap: 9px; }

  .logo-icon {
    width: 30px; height: 30px;
    background: linear-gradient(135deg, var(--accent), var(--green));
    border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 14px; color: #000;
  }

  .logo-text {
    font-weight: 800; font-size: 18px; letter-spacing: 3px;
    background: linear-gradient(135deg, #fff, #8890b0);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }

  .asset-pill {
    display: flex; align-items: center; gap: 10px;
    padding: 6px 14px 6px 8px;
    background: var(--surface-2); border: 1px solid var(--border); border-radius: 10px;
  }

  .asset-icon {
    width: 28px; height: 28px; border-radius: 50%;
    background: linear-gradient(135deg, #f7931a, #ff9500);
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 13px; color: #fff;
  }

  .asset-name-sm { font-weight: 700; font-size: 14px; }
  .asset-pair-sm { color: var(--text-dim); font-size: 12px; }

  .price-live { display: flex; align-items: baseline; gap: 10px; }

  .current-price {
    font-family: 'JetBrains Mono', monospace;
    font-size: 22px; font-weight: 700; letter-spacing: -0.5px;
  }

  .price-change { font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; }
  .price-change.up { color: var(--green); }
  .price-change.down { color: var(--red); }

  .header-right { display: flex; align-items: center; gap: 16px; }

  .live-badge {
    display: flex; align-items: center; gap: 5px;
    font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--green);
    padding: 4px 10px; background: var(--green-dim); border-radius: 6px;
    border: 1px solid rgba(0, 232, 123, 0.2);
  }

  .live-dot {
    width: 6px; height: 6px; background: var(--green);
    border-radius: 50%; animation: blink 1s ease-in-out infinite;
  }

  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

  .wallet-btn {
    padding: 8px 18px; background: linear-gradient(135deg, var(--accent), #9b7dff);
    border: none; border-radius: 8px; color: #fff;
    font-family: 'Outfit', sans-serif; font-size: 13px; font-weight: 700;
    cursor: pointer; transition: all 0.2s;
    box-shadow: 0 0 20px rgba(123, 97, 255, 0.3);
  }
  
  .wallet-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 0 25px rgba(123, 97, 255, 0.5);
  }
  
  .wallet-btn:active { transform: translateY(0); }

  .balance-pill {
    display: flex; align-items: center; gap: 7px;
    padding: 6px 14px; background: var(--surface-2);
    border: 1px solid var(--border); border-radius: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600;
    cursor: pointer; transition: all 0.2s;
  }
  
  .balance-pill:hover {
    background: var(--surface);
    border-color: var(--accent);
  }

  .bal-icon {
    width: 7px; height: 7px; border-radius: 50%;
    background: var(--green); box-shadow: 0 0 6px var(--green-glow);
  }

  .main {
    flex: 1; display: grid;
    grid-template-columns: 1fr 320px;
    min-height: 0;
  }

  .chart-wrap {
    position: relative; min-height: 0;
    border-right: 1px solid var(--border);
  }

  .chart-wrap canvas { position: absolute; inset: 0; }

  .chart-toolbar {
    position: absolute; top: 12px; left: 14px;
    display: flex; gap: 6px; z-index: 10;
  }

  .tb-btn {
    padding: 5px 12px; border: 1px solid var(--border); border-radius: 7px;
    background: rgba(12, 14, 22, 0.85); backdrop-filter: blur(10px);
    color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
    font-size: 10px; cursor: pointer; transition: all 0.2s; user-select: none;
  }

  .tb-btn:hover { border-color: var(--accent); color: var(--text); }
  .tb-btn.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(123,97,255,0.4); }
  .tb-btn.danger:hover { border-color: var(--red); color: var(--red); }

  .profit-indicator {
    position: absolute; top: 12px; right: 14px; z-index: 10;
    padding: 6px 14px; border-radius: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 700;
    opacity: 0; transition: all 0.3s; pointer-events: none;
  }

  .profit-indicator.show-profit {
    opacity: 1; background: rgba(0,232,123,0.15); color: var(--green);
    border: 1px solid rgba(0,232,123,0.35);
    box-shadow: 0 0 24px rgba(0,232,123,0.15);
    animation: profitBounce 0.8s ease-in-out infinite;
  }

  .profit-indicator.show-waiting {
    opacity: 0.7; background: rgba(94,100,136,0.12);
    color: var(--text-dim); border: 1px solid var(--border);
  }

  @keyframes profitBounce { 0%,100%{transform:scale(1)} 50%{transform:scale(1.04)} }

  .grid-info {
    position: absolute; bottom: 14px; left: 14px;
    display: flex; gap: 6px; z-index: 10; pointer-events: none;
  }

  .gi-pill {
    padding: 5px 10px; border-radius: 6px;
    font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: 600;
    backdrop-filter: blur(12px); border: 1px solid;
  }

  .gi-cells { background: rgba(123,97,255,0.12); color: var(--accent); border-color: rgba(123,97,255,0.25); }
  .gi-mult { background: rgba(255,214,10,0.08); color: var(--yellow); border-color: rgba(255,214,10,0.2); }

  /* Sidebar */
  .sidebar {
    display: flex; flex-direction: column;
    background: var(--surface); overflow-y: auto;
  }

  .sidebar-section { padding: 16px 18px; border-bottom: 1px solid var(--border); }

  .section-title {
    font-size: 9px; text-transform: uppercase; letter-spacing: 2px;
    color: var(--text-dim); margin-bottom: 12px; font-weight: 600;
  }

  .timer-row { display: flex; align-items: center; gap: 14px; }

  .countdown-ring { position: relative; width: 72px; height: 72px; flex-shrink: 0; }

  .countdown-ring svg { transform: rotate(-90deg); width: 72px; height: 72px; }
  .countdown-ring .track { fill: none; stroke: var(--surface-2); stroke-width: 5; }

  .countdown-ring .progress {
    fill: none; stroke: var(--accent); stroke-width: 5; stroke-linecap: round;
    stroke-dasharray: 201; stroke-dashoffset: 0;
    transition: stroke-dashoffset 1s linear, stroke 0.5s;
    filter: drop-shadow(0 0 5px rgba(123,97,255,0.4));
  }

  .countdown-ring .progress.warning { stroke: var(--yellow); filter: drop-shadow(0 0 5px rgba(255,214,10,0.4)); }
  .countdown-ring .progress.danger { stroke: var(--red); filter: drop-shadow(0 0 5px rgba(255,59,92,0.4)); }

  .countdown-center {
    position: absolute; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  .countdown-time { font-family: 'JetBrains Mono', monospace; font-size: 24px; font-weight: 800; }
  .countdown-label { font-size: 7px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; }

  .round-meta { display: flex; flex-direction: column; gap: 3px; }
  .round-number { font-family: 'JetBrains Mono', monospace; font-size: 13px; color: var(--accent); font-weight: 700; }
  .round-status { font-size: 11px; color: var(--text-dim); }
  .round-open-price { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--text-dim); margin-top: 2px; }
  .round-open-price span { color: var(--text); font-weight: 600; }

  .how-steps { display: flex; flex-direction: column; gap: 7px; }

  .how-step { display: flex; gap: 9px; align-items: flex-start; }

  .how-num {
    width: 20px; height: 20px; border-radius: 5px;
    background: var(--accent-dim); color: var(--accent);
    font-family: 'JetBrains Mono', monospace; font-size: 10px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }

  .how-text { font-size: 11.5px; color: var(--text-dim); line-height: 1.35; }
  .how-text b { color: var(--text); font-weight: 600; }

  .bet-section { display: flex; flex-direction: column; gap: 10px; }
  .bet-input-wrap { position: relative; }

  .bet-input-wrap .cur {
    position: absolute; left: 12px; top: 50%; transform: translateY(-50%);
    color: var(--text-dim); font-family: 'JetBrains Mono', monospace; font-size: 13px;
  }

  .bet-input {
    width: 100%; padding: 10px 10px 10px 24px;
    background: var(--bg); border: 1px solid var(--border); border-radius: 9px;
    color: var(--text); font-family: 'JetBrains Mono', monospace;
    font-size: 18px; font-weight: 700; outline: none; transition: border-color 0.2s;
  }

  .bet-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }

  .bet-presets { display: flex; gap: 4px; }

  .preset-btn {
    padding: 7px 0; flex: 1;
    border: 1px solid var(--border); border-radius: 6px;
    background: var(--bg); color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
    cursor: pointer; transition: all 0.2s;
  }

  .preset-btn:hover { border-color: var(--accent); color: var(--text); }

  .stats-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }

  .stat-card {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 7px; padding: 8px 6px; text-align: center;
  }

  .stat-card-label { font-size: 8px; text-transform: uppercase; letter-spacing: 0.7px; color: var(--text-dim); margin-bottom: 3px; }
  .stat-card-val { font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; }
  .sc-accent { color: var(--accent); }
  .sc-yellow { color: var(--yellow); }
  .sc-green { color: var(--green); }

  .place-btn {
    width: 100%; padding: 13px; border: none; border-radius: 11px;
    font-family: 'Outfit', sans-serif; font-size: 14px; font-weight: 700;
    letter-spacing: 0.5px; text-transform: uppercase; cursor: pointer;
    transition: all 0.3s; position: relative; overflow: hidden;
    background: linear-gradient(135deg, var(--accent), #9b7bff);
    color: #fff; box-shadow: 0 4px 18px rgba(123,97,255,0.3);
  }
  
  .place-btn:not(:disabled):not(.locked) {
    animation: buttonPulse 2s ease-in-out infinite;
  }
  
  @keyframes buttonPulse {
    0%, 100% { box-shadow: 0 4px 18px rgba(123,97,255,0.3); }
    50% { box-shadow: 0 4px 28px rgba(123,97,255,0.6), 0 0 40px rgba(123,97,255,0.3); }
  }

  .place-btn:hover:not(:disabled) { 
    transform: translateY(-2px) scale(1.02); 
    box-shadow: 0 8px 32px rgba(123,97,255,0.5);
    animation: none;
  }
  .place-btn:active:not(:disabled) { transform: translateY(0) scale(0.98); }
  .place-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; animation: none; }
  .place-btn.locked { background: var(--surface-2); color: var(--text-dim); box-shadow: none; cursor: default; opacity: 1; }

  .place-btn.in-profit {
    background: linear-gradient(135deg, #00c766, var(--green));
    box-shadow: 0 0 24px var(--green-glow); color: #000; font-weight: 800; opacity: 1;
  }

  .place-btn::after {
    content: ''; position: absolute; inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent);
    transform: translateX(-100%); animation: shimmer 3s infinite;
  }

  @keyframes shimmer { 100% { transform: translateX(100%); } }

  .legend-row { display: flex; gap: 12px; padding-top: 6px; flex-wrap: wrap; }

  .legend-item {
    display: flex; align-items: center; gap: 4px;
    font-family: 'JetBrains Mono', monospace; font-size: 9px; color: var(--text-dim);
  }

  .legend-sw { width: 8px; height: 8px; border-radius: 2px; }

  .trade-log { display: flex; flex-direction: column; gap: 4px; }

  .trade-entry {
    display: flex; align-items: center; justify-content: space-between;
    padding: 7px 10px; background: var(--bg); border-radius: 6px;
    border: 1px solid var(--border);
    font-family: 'JetBrains Mono', monospace; font-size: 10px;
    animation: fadeIn 0.3s ease;
  }

  .trade-id { color: var(--text-dim); }
  .tag-win { padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: 700; background: var(--green-dim); color: var(--green); }
  .tag-loss { padding: 2px 6px; border-radius: 3px; font-size: 8px; font-weight: 700; background: var(--red-dim); color: var(--red); }
  .pnl-pos { color: var(--green); font-weight: 700; }
  .pnl-neg { color: var(--red); font-weight: 700; }

  .profit-flash {
    position: fixed; inset: 0; pointer-events: none; z-index: 9998;
    opacity: 0; transition: opacity 0.2s;
    background: radial-gradient(circle at 50% 50%, rgba(0,232,123,0.15), transparent 60%);
  }

  .profit-flash.active { 
    opacity: 1;
    animation: flashPulse 0.4s ease-out;
  }
  
  @keyframes flashPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }

  @keyframes fadeIn { from { opacity:0; transform:translateY(-5px); } to { opacity:1; transform:translateY(0); } }

  @media (max-width: 900px) {
    .main { grid-template-columns: 1fr; grid-template-rows: 1fr auto; }
    .chart-wrap { border-right: none; min-height: 350px; }
    .sidebar { max-height: 50vh; }
  }
</style>
</head>
<body>

<div class="profit-flash" id="profitFlash"></div>

<div class="header">
  <div class="header-left">
    <div class="logo"><div class="logo-icon">R</div><div class="logo-text">RushTrade</div></div>
    <div class="asset-pill">
      <div class="asset-icon">â‚¿</div>
      <span class="asset-name-sm">BTC <span class="asset-pair-sm">/ USDT</span></span>
    </div>
    <div class="price-live">
      <span class="current-price" id="currentPrice">$97,241.38</span>
      <span class="price-change up" id="priceChange">+0.42%</span>
    </div>
  </div>
  <div class="header-right">
    <div class="live-badge"><span class="live-dot"></span> LIVE</div>
    <div class="live-badge" id="contractStatus" style="display: none; background: var(--surface-2); border: 1px solid var(--border); color: var(--text-dim);">
      <span class="live-dot" style="background: var(--accent); box-shadow: 0 0 6px var(--accent);"></span> 
      <span id="contractStatusText">Contracts</span>
    </div>
    <button class="wallet-btn" id="walletBtn" style="display: none;">Connect Wallet</button>
    <div class="balance-pill" id="balancePill" style="display: none;"><span class="bal-icon"></span> <span id="balance">$1,000.00</span></div>
  </div>
</div>

<div class="main">
  <div class="chart-wrap" id="chartWrap">
    <canvas id="mainCanvas"></canvas>
    <div class="chart-toolbar">
      <button class="tb-btn active" id="btnPaint">âœ¦ Paint</button>
      <button class="tb-btn" id="btnErase">âœ• Erase</button>
      <button class="tb-btn danger" id="btnClear">Clear All</button>
    </div>
    <div class="profit-indicator" id="profitInd"></div>
    <div class="grid-info">
      <div class="gi-pill gi-cells" id="giCells">0 cells</div>
      <div class="gi-pill gi-mult" id="giMult">â€”</div>
    </div>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <div class="section-title">Round</div>
      <div class="timer-row">
        <div class="countdown-ring">
          <svg viewBox="0 0 72 72">
            <circle class="track" cx="36" cy="36" r="32"/>
            <circle class="progress" id="timerProgress" cx="36" cy="36" r="32"/>
          </svg>
          <div class="countdown-center">
            <div class="countdown-time" id="countdownTime">60</div>
            <div class="countdown-label">sec</div>
          </div>
        </div>
        <div class="round-meta">
          <div class="round-number" id="roundNumber">#12,848</div>
          <div class="round-status" id="roundStatus">Accepting bets</div>
          <div class="round-open-price">Open: <span id="openPrice">$97,241</span></div>
        </div>
      </div>
    </div>

    <div class="sidebar-section">
      <div class="section-title">How to Play</div>
      <div class="how-steps">
        <div class="how-step"><div class="how-num">1</div><div class="how-text"><b>Paint zones</b> on the chart grid where you predict price will go</div></div>
        <div class="how-step"><div class="how-num">2</div><div class="how-text"><b>Fewer cells = bigger payout.</b> A 3s buffer keeps it fair â€” no painting the present</div></div>
        <div class="how-step"><div class="how-num">3</div><div class="how-text">When the <b>price cursor</b> hits your zone, you're <b style="color:var(--green)">in profit</b></div></div>
      </div>
    </div>

    <div class="sidebar-section">
      <div class="section-title">Stake</div>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 8px 12px; background: var(--surface-2); border-radius: 8px; border: 1px solid var(--border);">
        <span style="font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px;">ðŸ’µ USDC Balance</span>
        <span id="usdcBalance" style="font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; color: var(--green);">--</span>
      </div>
      <div class="bet-section">
        <div class="bet-input-wrap">
          <span class="cur">$</span>
          <input type="number" class="bet-input" id="betInput" value="50" min="1">
        </div>
        <div class="bet-presets">
          <button class="preset-btn" onclick="setBet(10)">$10</button>
          <button class="preset-btn" onclick="setBet(25)">$25</button>
          <button class="preset-btn" onclick="setBet(50)">$50</button>
          <button class="preset-btn" onclick="setBet(100)">$100</button>
        </div>
        <div class="stats-row">
          <div class="stat-card"><div class="stat-card-label">Cells</div><div class="stat-card-val sc-accent" id="dCells">0</div></div>
          <div class="stat-card"><div class="stat-card-label">Multi</div><div class="stat-card-val sc-yellow" id="dMult">â€”</div></div>
          <div class="stat-card"><div class="stat-card-label">Payout</div><div class="stat-card-val sc-green" id="dPay">â€”</div></div>
        </div>
        <button class="place-btn" id="placeBtn" disabled>Select zones on chart</button>
        <div class="legend-row">
          <div class="legend-item"><div class="legend-sw" style="background:rgba(123,97,255,0.55)"></div>Your Zone</div>
          <div class="legend-item"><div class="legend-sw" style="background:rgba(0,232,123,0.65)"></div>In Profit</div>
          <div class="legend-item"><div class="legend-sw" style="background:rgba(0,212,255,0.6)"></div>Price</div>
          <div class="legend-item"><div class="legend-sw" style="background:repeating-linear-gradient(45deg,#ff3b5c22,#ff3b5c22 2px,transparent 2px,transparent 4px)"></div>Locked</div>
        </div>
      </div>
    </div>

    <div class="sidebar-section" style="border-bottom:none;flex:1;">
      <div class="section-title">Trade Log</div>
      <div class="trade-log" id="tradeLog"></div>
    </div>
  </div>
</div>

<script>
// ===== CONFIG =====
const GRID_COLS = 12;
const GRID_ROWS = 24;
const TOTAL_CELLS = GRID_COLS * GRID_ROWS;
const CIRC = 2 * Math.PI * 32;
const GRID_ZONE_RATIO = 0.55;
const CHART_PAD_TOP = 10;
const CHART_PAD_BOTTOM = 10;
const PRICE_LABEL_WIDTH = 58;
const BUFFER_SECONDS = 3; // 3-second no-bet buffer

// Each grid column spans this many seconds
const SECS_PER_COL = 60 / GRID_COLS; // 5s per column

// ===== WALLET STATE =====
let walletClient = null;
let publicClient = null;
let walletAddress = null;
let walletBalance = null;

// ===== STATE =====
let basePrice = 97241.38;
let currentPrice = basePrice;
let openPrice = basePrice;
let priceHistory = [];
let timeLeft = 57; // Match the 3-second offset
let roundNum = 12848;
let balanceVal = 1000;
let selectedCells = new Set();
let isMouseDown = false;
let toolMode = 'paint';
// Multiple bets support
let activeBets = []; // Array of {cells: Set, amount: number, hitCells: Set, profitTicks: number}
let currentBetAmount = 0;
let gridPriceHigh, gridPriceLow;
// Start 3 seconds into the round for better initial appearance
let roundStartTime = Date.now() - 3000;

// Start with just current price, no history
priceHistory.push(basePrice);
currentPrice = priceHistory[priceHistory.length - 1];
openPrice = currentPrice;
gridPriceHigh = currentPrice + 100;
gridPriceLow = currentPrice - 100;

// ===== CANVAS =====
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  const r = canvas.parentElement.getBoundingClientRect();
  canvas.width = r.width * devicePixelRatio;
  canvas.height = r.height * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  canvas.style.width = r.width + 'px';
  canvas.style.height = r.height + 'px';
}

// Returns the first column index that is open for betting
function getFirstBettableCol() {
  const elapsed = 60 - timeLeft;
  const bufferEnd = elapsed + BUFFER_SECONDS;
  // First column whose START time is >= bufferEnd
  const col = Math.ceil(bufferEnd / SECS_PER_COL);
  return Math.min(col, GRID_COLS); // can be GRID_COLS meaning nothing is bettable
}

function isCellLocked(col) {
  return col < getFirstBettableCol();
}

// Auto-remove selected cells that have become locked
function pruneLockedSelections() {
  // Only prune current selection, not locked bets
  const firstOpen = getFirstBettableCol();
  let changed = false;
  for (const key of selectedCells) {
    const c = parseInt(key.split('-')[1]);
    if (c < firstOpen) {
      selectedCells.delete(key);
      changed = true;
    }
  }
  if (changed) updateBetUI();
}

function draw() {
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;
  ctx.clearRect(0, 0, W, H);

  const chartH = H - CHART_PAD_TOP - CHART_PAD_BOTTOM;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;
  const gridW = gridEndX - gridStartX;
  const gridY = CHART_PAD_TOP;
  const cellW = gridW / GRID_COLS;
  const cellH = chartH / GRID_ROWS;
  const priceRange = gridPriceHigh - gridPriceLow;
  const toY = v => CHART_PAD_TOP + (1 - (v - gridPriceLow) / priceRange) * chartH;

  // Current position on grid with sub-second precision
  const elapsedMs = Date.now() - roundStartTime;
  const elapsedSec = Math.min(60, elapsedMs / 1000);
  // Fractional column for smooth cursor (based on elapsed + sub-second from price ticks)
  const tColFrac = elapsedSec / SECS_PER_COL;
  const tColC = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(tColFrac)));
  const pRow = Math.floor((1 - (currentPrice - gridPriceLow) / priceRange) * GRID_ROWS);
  const pRowC = Math.max(0, Math.min(GRID_ROWS - 1, pRow));

  const cursorKey = `${pRowC}-${tColC}`;
  
  // Collect all locked cells and hit cells from active bets
  let allLockedCells = new Set();
  let allHitCells = new Set();
  let anyInProfit = false;
  
  for (let bet of activeBets) {
    for (let cell of bet.cells) {
      allLockedCells.add(cell);
    }
    for (let cell of bet.hitCells) {
      allHitCells.add(cell);
    }
    if (bet.cells.has(cursorKey)) {
      anyInProfit = true;
    }
  }

  const firstBettable = getFirstBettableCol();

  // ===== GRID ZONE BACKGROUND =====
  ctx.fillStyle = 'rgba(123, 97, 255, 0.012)';
  ctx.fillRect(gridStartX, gridY, gridW, chartH);

  // Separator
  ctx.setLineDash([4, 4]);
  ctx.strokeStyle = 'rgba(123, 97, 255, 0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(gridStartX, 0); ctx.lineTo(gridStartX, H); ctx.stroke();
  ctx.setLineDash([]);

  // ===== LOCKED ZONE (past + buffer) =====
  if (firstBettable > 0) {
    const lockedW = firstBettable * cellW;

    // Dark overlay
    ctx.fillStyle = 'rgba(6, 7, 11, 0.55)';
    ctx.fillRect(gridStartX, gridY, lockedW, chartH);

    // Diagonal hatch pattern
    ctx.save();
    ctx.beginPath();
    ctx.rect(gridStartX, gridY, lockedW, chartH);
    ctx.clip();
    ctx.strokeStyle = 'rgba(255, 59, 92, 0.08)';
    ctx.lineWidth = 1;
    const step = 8;
    for (let i = -chartH; i < lockedW + chartH; i += step) {
      ctx.beginPath();
      ctx.moveTo(gridStartX + i, gridY);
      ctx.lineTo(gridStartX + i + chartH, gridY + chartH);
      ctx.stroke();
    }
    ctx.restore();

    // Buffer boundary line
    const bufferX = gridStartX + lockedW;
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(255, 59, 92, 0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(bufferX, gridY); ctx.lineTo(bufferX, gridY + chartH); ctx.stroke();
    ctx.setLineDash([]);

    // "LOCKED" label
    if (lockedW > 40) {
      ctx.save();
      ctx.font = '600 8px JetBrains Mono';
      ctx.fillStyle = 'rgba(255, 59, 92, 0.3)';
      ctx.textAlign = 'center';
      ctx.fillText('LOCKED', gridStartX + lockedW / 2, gridY + 14);
      ctx.restore();
    }
  }

  // ===== DRAW GRID CELLS =====
  // Pulsing animation for unlocked selected cells - BRAINROT MODE
  const pulseTime = Date.now() / 1000;
  const pulseValue = Math.sin(pulseTime * 4) * 0.5 + 0.5; // Faster pulse - oscillates between 0 and 1
  const glowPulse = Math.sin(pulseTime * 3.5) * 0.5 + 0.5; // Slightly offset glow pulse
  
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      const key = `${r}-${c}`;
      const x = gridStartX + c * cellW;
      const y = gridY + r * cellH;
      const isCurrentSelection = selectedCells.has(key);
      const isLockedBet = allLockedCells.has(key);
      const locked = isCellLocked(c);
      const isCursor = (r === pRowC && c === tColC);
      const isHit = isLockedBet && isCursor;
      const wasHit = allHitCells.has(key); // Check if this cell was previously hit

      if (isHit || wasHit) {
        // Cell is currently being hit OR was hit before - SATISFYING GREEN GLOW
        const hitGlow = isHit ? (0.8 + pulseValue * 0.2) : 0.4; // Active hit pulses brighter
        
        // Glowing effect for maximum dopamine
        ctx.shadowBlur = isHit ? 15 + pulseValue * 10 : 8;
        ctx.shadowColor = `rgba(0, 232, 123, ${hitGlow})`;
        
        ctx.fillStyle = `rgba(0, 232, 123, ${isHit ? 0.5 + pulseValue * 0.2 : 0.4})`;
        ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        ctx.strokeStyle = isHit ? `rgba(0, 255, 140, ${0.9 + pulseValue * 0.1})` : '#00e87b';
        ctx.lineWidth = isHit ? 2 + pulseValue * 0.5 : 1.5;
        ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        
        ctx.shadowBlur = 0;
      } else if ((isCurrentSelection || isLockedBet) && !locked) {
        if (isLockedBet && !isCurrentSelection) {
          // Locked bet cell that hasn't been hit yet - dim it
          ctx.fillStyle = 'rgba(123,97,255,0.2)';
          ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
          ctx.strokeStyle = 'rgba(123,97,255,0.45)';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        } else if (isCurrentSelection) {
          // Bet NOT locked - BRAINROT PULSE MODE ðŸ”¥
          const fillAlpha = 0.3 + pulseValue * 0.25; // More intense pulse: 0.3 to 0.55
          const strokeAlpha = 0.5 + pulseValue * 0.4; // Brighter stroke: 0.5 to 0.9
          const glowAlpha = 0.15 + glowPulse * 0.25; // Glow effect
          
          // Outer glow for that dopamine hit
          ctx.shadowBlur = 8 + glowPulse * 12; // Pulsing glow
          ctx.shadowColor = `rgba(123,97,255,${glowAlpha * 2})`;
          
          // Main fill with vibrant color
          ctx.fillStyle = `rgba(123,97,255,${fillAlpha})`;
          ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
          
          // Bright pulsing border
          ctx.strokeStyle = `rgba(150,120,255,${strokeAlpha})`; // Brighter purple
          ctx.lineWidth = 1 + pulseValue * 1; // Thicker pulse: 1 to 2px
          ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
          
          // Reset shadow
          ctx.shadowBlur = 0;
        }
      } else if (isLockedBet && locked) {
        // Locked bet cell that's been passed â€” dim it out
        ctx.fillStyle = 'rgba(123,97,255,0.08)';
        ctx.fillRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
        ctx.strokeStyle = 'rgba(123,97,255,0.15)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x + 0.5, y + 0.5, cellW - 1, cellH - 1);
      }
    }
  }

  // Grid lines
  ctx.strokeStyle = 'rgba(30, 34, 53, 0.3)';
  ctx.lineWidth = 0.5;
  for (let r = 0; r <= GRID_ROWS; r++) {
    const y = gridY + r * cellH;
    ctx.beginPath(); ctx.moveTo(gridStartX, y); ctx.lineTo(gridEndX, y); ctx.stroke();
  }
  for (let c = 0; c <= GRID_COLS; c++) {
    const x = gridStartX + c * cellW;
    ctx.beginPath(); ctx.moveTo(x, gridY); ctx.lineTo(x, gridY + chartH); ctx.stroke();
  }

  // ===== PRICE CHART =====
  const data = priceHistory.slice(-100);
  if (data.length >= 2) {
    const chartEndX = gridStartX + gridW * 0.15;
    const chartStartX = 10;
    const cW = chartEndX - chartStartX;
    const toChartX = i => chartStartX + (i / (data.length - 1)) * cW;

    const last = data[data.length - 1];
    const first = data[0];
    const isUp = last >= first;
    const col = isUp ? '#00e87b' : '#ff3b5c';

    // Area
    const grad = ctx.createLinearGradient(0, CHART_PAD_TOP, 0, H);
    grad.addColorStop(0, isUp ? 'rgba(0,232,123,0.08)' : 'rgba(255,59,92,0.08)');
    grad.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.moveTo(toChartX(0), H);
    for (let i = 0; i < data.length; i++) {
      const x = toChartX(i), y = toY(data[i]);
      if (i === 0) ctx.lineTo(x, y);
      else { const px = toChartX(i-1), cp = (px+x)/2; ctx.bezierCurveTo(cp, toY(data[i-1]), cp, y, x, y); }
    }
    ctx.lineTo(toChartX(data.length - 1), H);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();

    // Line
    ctx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = toChartX(i), y = toY(data[i]);
      if (i === 0) ctx.moveTo(x, y);
      else { const px = toChartX(i-1), cp = (px+x)/2; ctx.bezierCurveTo(cp, toY(data[i-1]), cp, y, x, y); }
    }
    ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.stroke();
    ctx.strokeStyle = isUp ? 'rgba(0,232,123,0.15)' : 'rgba(255,59,92,0.15)'; ctx.lineWidth = 6; ctx.stroke();

    // Dot
    const dotX = toChartX(data.length - 1), dotY = toY(last);
    ctx.beginPath(); ctx.arc(dotX, dotY, 4, 0, Math.PI*2); ctx.fillStyle = col; ctx.fill();
    ctx.beginPath(); ctx.arc(dotX, dotY, 9, 0, Math.PI*2); ctx.fillStyle = isUp ? 'rgba(0,232,123,0.12)' : 'rgba(255,59,92,0.12)'; ctx.fill();

    // Dashed line across
    ctx.setLineDash([4,4]);
    ctx.strokeStyle = 'rgba(0,212,255,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(W, dotY); ctx.stroke();
    ctx.setLineDash([]);
  }

  // ===== PRICE CURSOR ON GRID =====
  const priceY = toY(currentPrice);
  // Blue dot position aligned with grid cells
  const timeXSnapped = gridStartX + (tColC + 0.5) * cellW;

  // Crosshairs
  ctx.setLineDash([5,3]);
  ctx.strokeStyle = 'rgba(0,212,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(gridStartX, priceY); ctx.lineTo(gridEndX, priceY); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,214,10,0.18)';
  ctx.beginPath(); ctx.moveTo(timeXSnapped, gridY); ctx.lineTo(timeXSnapped, gridY + chartH); ctx.stroke();
  ctx.setLineDash([]);

  // Cursor dot
  const dotColor = anyInProfit ? '#00e87b' : '#00d4ff';
  ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 5, 0, Math.PI*2); ctx.fillStyle = dotColor; ctx.fill();
  ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 11, 0, Math.PI*2);
  ctx.fillStyle = anyInProfit ? 'rgba(0,232,123,0.18)' : 'rgba(0,212,255,0.1)'; ctx.fill();

  if (anyInProfit) {
    ctx.beginPath(); ctx.arc(timeXSnapped, priceY, 18, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,232,123,0.06)'; ctx.fill();
  }

  // ===== LABELS =====
  ctx.font = '10px JetBrains Mono';
  ctx.textAlign = 'right';
  ctx.fillStyle = '#4a5070';
  const labelStep = Math.max(1, Math.floor(GRID_ROWS / 6));
  for (let r = 0; r <= GRID_ROWS; r += labelStep) {
    const y = gridY + r * cellH;
    const pv = gridPriceHigh - (r / GRID_ROWS) * priceRange;
    ctx.fillText('$' + pv.toFixed(0), W - 6, y + 3);
  }

  // Current price tag
  ctx.fillStyle = anyInProfit ? '#00e87b' : '#00d4ff';
  const priceTag = '$' + currentPrice.toFixed(0);
  const tagW = ctx.measureText(priceTag).width + 14;
  const tagH = 20;
  const tagX = W - PRICE_LABEL_WIDTH + 4;
  const tagYPos = priceY - tagH / 2;
  ctx.beginPath(); ctx.roundRect(tagX, tagYPos, tagW, tagH, 4); ctx.fill();
  ctx.fillStyle = '#000'; ctx.font = 'bold 10px JetBrains Mono'; ctx.textAlign = 'left';
  ctx.fillText(priceTag, tagX + 7, priceY + 3.5);

  // Time labels
  ctx.textAlign = 'center'; ctx.fillStyle = '#3a3f5a'; ctx.font = '9px JetBrains Mono';
  for (let c = 0; c < GRID_COLS; c += 2) {
    const sec = Math.round(c * SECS_PER_COL);
    ctx.fillText(sec + 's', gridStartX + c * cellW + cellW / 2, H - 2);
  }

  // Zone label
  ctx.save();
  ctx.font = '600 9px Outfit';
  ctx.fillStyle = 'rgba(123,97,255,0.2)';
  ctx.textAlign = 'center';
  const openZoneCenter = gridStartX + (firstBettable * cellW + gridW) / 2;
  if (firstBettable < GRID_COLS) {
    ctx.fillText('P R E D I C T I O N   Z O N E', openZoneCenter, gridY + 14);
  }
  ctx.restore();

  // Horizontal chart gridlines (left of grid)
  ctx.strokeStyle = 'rgba(30,34,53,0.2)'; ctx.lineWidth = 0.5;
  for (let r = 0; r <= GRID_ROWS; r += labelStep) {
    const y = gridY + r * cellH;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(gridStartX, y); ctx.stroke();
  }

  // ===== PROFIT STATE =====
  // Update each bet's hit tracking
  let totalProfit = 0;
  let anyBetInProfit = false;
  
  for (let bet of activeBets) {
    const wasInProfit = bet.cells.has(cursorKey);
    if (wasInProfit) {
      if (!bet.hitCells.has(cursorKey)) {
        // First time hitting this cell
        document.getElementById('profitFlash').classList.add('active');
        setTimeout(() => document.getElementById('profitFlash').classList.remove('active'), 500);
      }
      bet.hitCells.add(cursorKey);
      bet.profitTicks++;
      anyBetInProfit = true;
    }
    
    // Calculate profit for this bet
    if (bet.profitTicks > 0) {
      const payout = bet.amount * getMult(bet.cells.size);
      totalProfit += payout - bet.amount;
    }
  }

  const pInd = document.getElementById('profitInd');
  if (activeBets.length > 0) {
    if (totalProfit > 0) {
      pInd.className = 'profit-indicator show-profit';
      pInd.textContent = `â— IN PROFIT +$${totalProfit.toFixed(0)}`;
    } else {
      pInd.className = 'profit-indicator show-waiting';
      pInd.textContent = `â³ ${activeBets.length} bet${activeBets.length > 1 ? 's' : ''} active...`;
    }
  } else {
    pInd.className = 'profit-indicator';
  }

  // Show current selection info in grid info
  const totalCells = selectedCells.size + allLockedCells.size;
  document.getElementById('giCells').textContent = totalCells + ' cells';
  const m = getMult(totalCells);
  document.getElementById('giMult').textContent = totalCells > 0 ? (m.toFixed(1) + 'x') : 'â€”';
}

// ===== GRID INTERACTION =====
function getGridCell(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
  const my = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
  const W = rect.width;
  const H = rect.height;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;
  const gridW = gridEndX - gridStartX;
  const chartH = H - CHART_PAD_TOP - CHART_PAD_BOTTOM;

  if (mx < gridStartX || mx > gridEndX || my < CHART_PAD_TOP || my > CHART_PAD_TOP + chartH) return null;

  const col = Math.floor((mx - gridStartX) / (gridW / GRID_COLS));
  const row = Math.floor((my - CHART_PAD_TOP) / (chartH / GRID_ROWS));
  if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) return null;

  // Enforce buffer: can't paint locked columns
  if (isCellLocked(col)) return null;

  return `${row}-${col}`;
}

function onStart(e) {
  const key = getGridCell(e);
  if (!key) return;
  isMouseDown = true;
  if (toolMode === 'paint') selectedCells.add(key);
  else selectedCells.delete(key);
  updateBetUI(); draw();
}

function onMove(e) {
  if (!isMouseDown) return;
  const key = getGridCell(e);
  if (!key) return;
  if (toolMode === 'paint') selectedCells.add(key);
  else selectedCells.delete(key);
  updateBetUI(); draw();
}

function onEnd() { isMouseDown = false; }

canvas.addEventListener('mousedown', onStart);
canvas.addEventListener('mousemove', onMove);
document.addEventListener('mouseup', onEnd);
canvas.addEventListener('touchstart', e => { e.preventDefault(); onStart(e); }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e); }, { passive: false });
canvas.addEventListener('touchend', onEnd);

// Cursor style: crosshair in grid zone, default outside
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const W = rect.width;
  const gridStartX = W * (1 - GRID_ZONE_RATIO);
  const gridEndX = W - PRICE_LABEL_WIDTH;

  if (mx >= gridStartX && mx <= gridEndX) {
    const col = Math.floor((mx - gridStartX) / ((gridEndX - gridStartX) / GRID_COLS));
    canvas.style.cursor = isCellLocked(col) ? 'not-allowed' : 'crosshair';
  } else {
    canvas.style.cursor = 'default';
  }
});

document.getElementById('btnPaint').addEventListener('click', function() {
  toolMode = 'paint';
  this.classList.add('active');
  document.getElementById('btnErase').classList.remove('active');
});

document.getElementById('btnErase').addEventListener('click', function() {
  toolMode = 'erase';
  this.classList.add('active');
  document.getElementById('btnPaint').classList.remove('active');
});

document.getElementById('btnClear').addEventListener('click', () => {
  selectedCells.clear();
  updateBetUI(); draw();
});

// ===== BET LOGIC =====
function getMult(n) {
  if (n === 0) return 0;
  return Math.max(1.1, (TOTAL_CELLS / n) * 0.55);
}

function updateBetUI() {
  const cnt = selectedCells.size;
  const bet = parseFloat(document.getElementById('betInput').value) || 0;
  const m = getMult(cnt);
  document.getElementById('dCells').textContent = cnt;
  document.getElementById('dMult').textContent = cnt > 0 ? m.toFixed(1) + 'x' : 'â€”';
  document.getElementById('dPay').textContent = cnt > 0 ? '$' + (bet * m).toFixed(0) : 'â€”';

  const btn = document.getElementById('placeBtn');
  if (cnt > 0 && bet > 0) {
    btn.disabled = false;
    btn.textContent = activeBets.length > 0 ? `Place Another Bet â€” $${bet}` : `Lock Prediction â€” $${bet}`;
  } else {
    btn.disabled = true;
    btn.textContent = activeBets.length > 0 ? 'Select zones for next bet' : 'Select zones on chart';
  }
}

document.getElementById('betInput').addEventListener('input', updateBetUI);
function setBet(v) { document.getElementById('betInput').value = v; updateBetUI(); }

document.getElementById('placeBtn').addEventListener('click', async function() {
  if (selectedCells.size === 0) return;
  
  const betAmount = parseFloat(document.getElementById('betInput').value) || 0;
  if (betAmount <= 0) return;
  
  // Check if wallet is connected
  if (!walletAddress) {
    alert('Please connect your wallet first!');
    return;
  }
  
  // Check if on correct network
  try {
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    const currentChainId = parseInt(chainId, 16);
    if (currentChainId !== 10143) {
      alert(`Wrong network! Please switch to Monad Testnet (Chain ID: 10143).\n\nCurrent chain: ${currentChainId}\n\nTo add Monad Testnet:\n1. Open MetaMask\n2. Add Network Manually\n3. RPC: https://testnet-rpc.monad.xyz\n4. Chain ID: 10143\n5. Symbol: MON`);
      return;
    }
  } catch (error) {
    console.error('Error checking chain:', error);
  }
  
  // Check USDC balance
  if (parseFloat(usdcBalance) < betAmount) {
    alert(`Insufficient USDC balance. You have $${usdcBalance} but need $${betAmount}`);
    return;
  }
  
  // Disable button during transaction
  const btn = document.getElementById('placeBtn');
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Processing...';
  
  try {
    // Step 1: Approve USDC
    btn.textContent = 'Approving USDC...';
    const approved = await approveUSDC(betAmount);
    
    if (!approved) {
      throw new Error('USDC approval failed');
    }
    
    // Step 2: Create and sign order for CTFExchange
    btn.textContent = 'Creating order...';
    
    // For demo: use a mock condition ID (in production, this would come from MarketFactory)
    // This would be the conditionId for the current 60s round
    const mockConditionId = '0x' + '1'.repeat(64); // Mock condition ID
    const yesTokenId = 1; // YES token (indexSet = 1)
    
    // Create BUY order (user buys YES tokens with USDC)
    const order = {
      maker: walletAddress,
      tokenId: yesTokenId,
      makerAmount: BigInt(Math.floor(betAmount * 1e6)), // USDC amount (6 decimals)
      takerAmount: BigInt(Math.floor(betAmount * 1e6)), // Token amount (assume 1:1 for now)
      expiration: BigInt(Math.floor(Date.now() / 1000) + 3600), // 1 hour from now
      nonce: BigInt(Math.floor(Math.random() * 1000000)),
      feeRateBps: BigInt(50), // 0.5% fee
      side: 0, // BUY = 0
      signer: '0x0000000000000000000000000000000000000000' // No delegate signer
    };
    
    console.log('ðŸ“ Order created:', order);
    console.log('ðŸ’° Buying', betAmount, 'YES tokens for $', betAmount, 'USDC');
    
    // Step 3: Sign order with EIP-712
    btn.textContent = 'Sign order...';
    
    const domain = {
      name: 'CTFExchange',
      version: '1',
      chainId: 10143,
      verifyingContract: CONTRACTS.CTFExchange
    };
    
    const types = {
      Order: [
        { name: 'maker', type: 'address' },
        { name: 'tokenId', type: 'uint256' },
        { name: 'makerAmount', type: 'uint256' },
        { name: 'takerAmount', type: 'uint256' },
        { name: 'expiration', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'feeRateBps', type: 'uint256' },
        { name: 'side', type: 'uint8' },
        { name: 'signer', type: 'address' }
      ]
    };
    
    let signature;
    try {
      signature = await walletClient.signTypedData({
        account: walletAddress,
        domain,
        types,
        primaryType: 'Order',
        message: order
      });
      console.log('âœ… Order signed:', signature);
    } catch (signError) {
      console.error('Signing error:', signError);
      throw new Error('Failed to sign order: ' + signError.message);
    }
    
    // Step 4: Submit order to backend
    btn.textContent = 'Submitting to orderbook...';
    
    try {
      // Submit signed order to backend CLOB
      const orderPayload = {
        condition_id: mockConditionId,
        token_id: order.tokenId.toString(),
        side: order.side === 0 ? 'BUY' : 'SELL',
        maker_amount: order.makerAmount.toString(),
        taker_amount: order.takerAmount.toString(),
        expiration: order.expiration.toString(),
        nonce: order.nonce.toString(),
        fee_rate_bps: order.feeRateBps.toString(),
        signature: signature
      };
      
      console.log('ðŸ“¤ Submitting order to backend:', orderPayload);
      
      const response = await fetch('http://localhost:8000/api/v1/clob/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // TODO: Add auth token when user auth is implemented
        },
        body: JSON.stringify(orderPayload)
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Failed to submit order');
      }
      
      const result = await response.json();
      console.log('âœ… Order submitted successfully:', result);
      console.log('ðŸ”— Order ID:', result.id);
      console.log('ðŸ“Š Backend will match and execute on-chain via CTFExchange');
      
    } catch (tradeError) {
      console.error('Trade execution error:', tradeError);
      throw new Error('Failed to submit order: ' + tradeError.message);
    }
    
    // Add new bet to active bets
    activeBets.push({
      cells: new Set(selectedCells),
      amount: betAmount,
      hitCells: new Set(),
      profitTicks: 0,
      order: order,
      signature: signature
    });
    
    // Update USDC balance
    await updateUSDCBalance();
    
    // Clear selection for next bet
    selectedCells.clear();
    updateBetUI();
    draw();
    
    // Show success message
    btn.textContent = 'âœ… Bet Placed!';
    setTimeout(() => {
      btn.textContent = originalText;
      btn.disabled = false;
    }, 2000);
    
    console.log('âœ… Bet placed successfully!');
  } catch (error) {
    console.error('Error placing bet:', error);
    alert('Failed to place bet: ' + (error.message || 'Unknown error'));
    btn.textContent = originalText;
    btn.disabled = false;
  }
});

// ===== PRICE ENGINE =====
// BTC/USD price feed ID from Pyth
const BTC_USD_PRICE_FEED_ID = '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43';
let lastPythUpdate = 0;
let pythUpdateInterval = 1000; // Update from Pyth every 1 second

async function fetchPythPrice() {
  try {
    if (!window.pythReady) {
      return false;
    }
    
    // Fetch directly from Pyth Hermes API
    const response = await fetch(`https://hermes.pyth.network/v2/updates/price/latest?ids[]=${BTC_USD_PRICE_FEED_ID}`);
    
    if (!response.ok) {
      throw new Error(`Pyth API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.parsed && data.parsed.length > 0) {
      const priceData = data.parsed[0].price;
      // Convert price (Pyth returns price with exponent)
      const btcPrice = parseFloat(priceData.price) * Math.pow(10, priceData.expo);
      currentPrice = btcPrice;
      return true;
    } else {
      return false;
    }
  } catch (error) {
    console.error('Error fetching Pyth price:', error);
    // Fallback to simulated price movement if Pyth fails
    const vol = 5 + Math.random() * 10;
    currentPrice += (Math.random() - 0.497) * vol;
    return false;
  }
}

async function tick() {
  const now = Date.now();
  
  // Fetch real price from Pyth periodically
  if (now - lastPythUpdate > pythUpdateInterval) {
    await fetchPythPrice();
    lastPythUpdate = now;
  }
  
  priceHistory.push(currentPrice);
  if (priceHistory.length > 250) priceHistory.shift();

  const gc = (gridPriceHigh + gridPriceLow) / 2;
  const d = (currentPrice - gc) * 0.04;
  gridPriceHigh += d; gridPriceLow += d;

  document.getElementById('currentPrice').textContent = '$' + currentPrice.toFixed(2);
  const chg = ((currentPrice - openPrice) / openPrice * 100);
  const ce = document.getElementById('priceChange');
  ce.textContent = (chg >= 0 ? '+' : '') + chg.toFixed(2) + '%';
  ce.className = 'price-change ' + (chg >= 0 ? 'up' : 'down');

  // Prune cells that have become locked (past + buffer)
  pruneLockedSelections();

  draw();
}

// ===== TIMER =====
function timerTick() {
  timeLeft--;
  if (timeLeft < 0) { resolveRound(); return; }
  document.getElementById('countdownTime').textContent = timeLeft;
  const p = document.getElementById('timerProgress');
  p.style.strokeDasharray = CIRC;
  p.style.strokeDashoffset = CIRC * (1 - timeLeft / 60);
  p.classList.remove('warning', 'danger');
  if (timeLeft <= 10) p.classList.add('danger');
  else if (timeLeft <= 20) p.classList.add('warning');
  if (timeLeft <= 10) {
    document.getElementById('roundStatus').textContent = 'Closing soon!';
    document.getElementById('roundStatus').style.color = '#ff3b5c';
  }
}

function resolveRound() {
  // Resolve all active bets
  for (let bet of activeBets) {
    const m = getMult(bet.cells.size);
    const payout = bet.amount * m;
    if (bet.profitTicks > 0) {
      balanceVal += payout - bet.amount;
      addTrade(roundNum, true, payout - bet.amount);
    } else {
      balanceVal -= bet.amount;
      addTrade(roundNum, false, -bet.amount);
    }
  }
  
  // Update balance display
  if (activeBets.length > 0) {
    document.getElementById('balance').textContent = '$' + balanceVal.toFixed(2);
  }

  // Reset for new round
  activeBets = [];
  selectedCells.clear();
  roundNum++; 
  timeLeft = 60;
  roundStartTime = Date.now();
  openPrice = currentPrice;
  gridPriceHigh = currentPrice + 100;
  gridPriceLow = currentPrice - 100;
  
  // Clear price history to sync with new round, keep last 2 points for continuity
  priceHistory = priceHistory.slice(-2);

  document.getElementById('roundNumber').textContent = '#' + roundNum.toLocaleString();
  document.getElementById('roundStatus').textContent = 'Accepting bets';
  document.getElementById('roundStatus').style.color = '';
  document.getElementById('openPrice').textContent = '$' + openPrice.toFixed(0);
  document.getElementById('timerProgress').classList.remove('warning', 'danger');
  updateBetUI(); draw();
}

function addTrade(id, won, pnl) {
  const c = document.getElementById('tradeLog');
  const d = document.createElement('div');
  d.className = 'trade-entry';
  d.innerHTML = `<span class="trade-id">#${id.toLocaleString()}</span><span class="${won?'tag-win':'tag-loss'}">${won?'WIN':'LOSS'}</span><span class="${won?'pnl-pos':'pnl-neg'}">${pnl>=0?'+':''}$${pnl.toFixed(0)}</span>`;
  c.insertBefore(d, c.firstChild);
  if (c.children.length > 8) c.removeChild(c.lastChild);
}

// ===== WALLET FUNCTIONS =====
async function switchToMonadTestnet() {
  if (!window.ethereum) return;
  
  try {
    // Check current chain
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    const currentChainId = parseInt(chainId, 16);
    
    if (currentChainId === 10143) {
      console.log('âœ… Already on Monad Testnet');
      return;
    }
    
    console.log(`Switching from chain ${currentChainId} to Monad Testnet (10143)...`);
    
    // Detect if using Brave Wallet
    const isBrave = navigator.brave && await navigator.brave.isBrave();
    
    try {
      // Try to switch to Monad Testnet
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: '0x279F' }], // 10143 in hex
      });
      console.log('âœ… Switched to Monad Testnet');
    } catch (switchError) {
      console.log('Switch error code:', switchError.code);
      
      // Error code 4902 means chain not added, -32603 can mean RPC error
      if (switchError.code === 4902 || switchError.code === -32603 || switchError.code === 4001) {
        try {
          console.log('Attempting to add Monad Testnet...');
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [
              {
                chainId: '0x279F', // 10143 in hex
                chainName: 'Monad Testnet',
                nativeCurrency: {
                  name: 'Monad',
                  symbol: 'MON',
                  decimals: 18,
                },
                rpcUrls: ['https://testnet-rpc.monad.xyz'],
                blockExplorerUrls: ['https://testnet.monadscan.com'],
              },
            ],
          });
          console.log('âœ… Monad Testnet added successfully');
          
          // Try switching again after adding
          setTimeout(async () => {
            try {
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x279F' }],
              });
              console.log('âœ… Switched to Monad Testnet after adding');
            } catch (e) {
              console.log('Please manually switch to Monad Testnet');
            }
          }, 500);
        } catch (addError) {
          console.error('Error adding Monad Testnet:', addError);
          
          // Show user-friendly instructions for Brave Wallet
          if (isBrave) {
            alert(`Please add Monad Testnet manually in Brave Wallet:\n\n1. Click Brave Wallet icon\n2. Settings â†’ Networks â†’ Add\n3. Network Name: Monad Testnet\n4. RPC URL: https://testnet-rpc.monad.xyz\n5. Chain ID: 10143\n6. Symbol: MON\n7. Explorer: https://testnet.monadscan.com\n\nThen refresh this page.`);
          }
          throw addError;
        }
      } else {
        throw switchError;
      }
    }
  } catch (error) {
    console.error('Error switching network:', error);
    // Don't block - user can manually switch
    console.warn('âš ï¸ Please manually switch to Monad Testnet in your wallet');
  }
}

async function connectWallet() {
  try {
    if (!window.ethereum) {
      alert('Please install MetaMask to use this app!');
      return;
    }

    // Wait for viem to load
    if (!window.viem) {
      console.log('Waiting for viem to load...');
      setTimeout(connectWallet, 100);
      return;
    }

    const { createWalletClient, custom, formatEther, createPublicClient, http, monadTestnet } = window.viem;

    // Request account access
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    walletAddress = accounts[0];

    // Create wallet client
    walletClient = createWalletClient({
      chain: monadTestnet,
      transport: custom(window.ethereum)
    });

    // Create public client for reading
    publicClient = createPublicClient({
      chain: monadTestnet,
      transport: http('https://testnet-rpc.monad.xyz')
    });

    // Get balance
    await updateWalletBalance();

    // Update UI
    updateWalletUI();

    // Listen for account changes
    window.ethereum.on('accountsChanged', handleAccountsChanged);
    window.ethereum.on('chainChanged', () => window.location.reload());

    // Switch to Monad Testnet if needed
    await switchToMonadTestnet();

    // Initialize contracts
    await initializeContracts();

  } catch (error) {
    console.error('Error connecting wallet:', error);
    alert('Failed to connect wallet. Please try again.');
  }
}

// ===== CONTRACT INTEGRATION =====
const CONTRACTS = {
  ConditionalTokens: '0x5ec0724ea68a8f5c8ae7a87eafe136730252f1ff',
  MarketFactory: '0xba465e13d3d5fb09627ebab1ea6e86293438c5e3',
  CTFExchange: '0x5121fe4e7ba3130c56ea3e9e0c67c1b8eacccaa1',
  USDC: '0x534b2f3a21130d7a60830c2df862319e593943a3'
};

let contractInstances = {};

async function initializeContracts() {
  if (!publicClient || !walletClient) {
    console.warn('Clients not initialized');
    return;
  }

  try {
    console.log('âœ… Contracts initialized:', CONTRACTS);
    console.log('ðŸ“ View on explorer: https://testnet.monadscan.com');
    
    // Store contract addresses for later use
    contractInstances = {
      ctf: CONTRACTS.ConditionalTokens,
      factory: CONTRACTS.MarketFactory,
      exchange: CONTRACTS.CTFExchange,
      usdc: CONTRACTS.USDC
    };
    
    // Log contract info to console for debugging
    console.log('Contract addresses loaded:', contractInstances);
    
    // Show contract status in UI
    const contractStatus = document.getElementById('contractStatus');
    const contractStatusText = document.getElementById('contractStatusText');
    if (contractStatus && contractStatusText) {
      contractStatus.style.display = 'flex';
      contractStatusText.textContent = 'Contracts Ready';
    }
    
    // Fetch USDC balance
    await updateUSDCBalance();
  } catch (error) {
    console.error('Error initializing contracts:', error);
  }
}

// ERC20 ABI (minimal - just what we need)
const ERC20_ABI = [
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "balance", "type": "uint256"}],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {"name": "_spender", "type": "address"},
      {"name": "_value", "type": "uint256"}
    ],
    "name": "approve",
    "outputs": [{"name": "", "type": "bool"}],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {"name": "_owner", "type": "address"},
      {"name": "_spender", "type": "address"}
    ],
    "name": "allowance",
    "outputs": [{"name": "", "type": "uint256"}],
    "type": "function"
  }
];

let usdcBalance = '0';

async function updateUSDCBalance() {
  if (!publicClient || !walletAddress) return;
  
  try {
    // Read USDC balance
    const balance = await publicClient.readContract({
      address: CONTRACTS.USDC,
      abi: ERC20_ABI,
      functionName: 'balanceOf',
      args: [walletAddress]
    });
    
    // USDC has 6 decimals
    usdcBalance = (Number(balance) / 1e6).toFixed(2);
    
    // Update UI
    const usdcBalanceEl = document.getElementById('usdcBalance');
    if (usdcBalanceEl) {
      usdcBalanceEl.textContent = `$${usdcBalance}`;
    }
    
    console.log('USDC Balance:', usdcBalance);
  } catch (error) {
    console.error('Error fetching USDC balance:', error);
    const usdcBalanceEl = document.getElementById('usdcBalance');
    if (usdcBalanceEl) {
      usdcBalanceEl.textContent = '$0.00';
    }
  }
}

async function checkUSDCAllowance(amount) {
  if (!publicClient || !walletAddress) return false;
  
  try {
    const amountInUnits = BigInt(Math.floor(amount * 1e6));
    
    // Check current allowance
    const allowance = await publicClient.readContract({
      address: CONTRACTS.USDC,
      abi: ERC20_ABI,
      functionName: 'allowance',
      args: [walletAddress, CONTRACTS.CTFExchange]
    });
    
    console.log('Current USDC allowance:', allowance.toString(), 'Need:', amountInUnits.toString());
    return allowance >= amountInUnits;
  } catch (error) {
    console.error('Error checking allowance:', error);
    return false;
  }
}

async function approveUSDC(amount) {
  if (!walletClient || !walletAddress) {
    alert('Please connect your wallet first');
    return false;
  }
  
  try {
    // Check if we already have sufficient allowance
    const hasAllowance = await checkUSDCAllowance(amount);
    if (hasAllowance) {
      console.log('âœ… Sufficient USDC allowance already exists');
      return true;
    }
    
    // Convert amount to USDC units (6 decimals)
    // Approve a larger amount to avoid frequent approvals (approve 10x the bet amount)
    const amountInUnits = BigInt(Math.floor(amount * 10 * 1e6));
    
    console.log('Requesting USDC approval for:', amountInUnits.toString());
    
    // Approve CTFExchange to spend USDC
    const { request } = await publicClient.simulateContract({
      address: CONTRACTS.USDC,
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [CONTRACTS.CTFExchange, amountInUnits],
      account: walletAddress
    });
    
    const hash = await walletClient.writeContract(request);
    console.log('Approval transaction:', hash);
    
    // Wait for confirmation
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    console.log('âœ… USDC approved, receipt:', receipt);
    return true;
  } catch (error) {
    console.error('Error approving USDC:', error);
    if (error.message.includes('User rejected')) {
      alert('Approval cancelled');
    } else {
      alert('Failed to approve USDC: ' + (error.shortMessage || error.message));
    }
    return false;
  }
}

async function updateWalletBalance() {
  if (!walletAddress || !publicClient) return;
  
  try {
    const { formatEther } = window.viem;
    
    // Use publicClient to fetch balance from the correct network
    const balance = await publicClient.getBalance({
      address: walletAddress
    });
    
    // Convert to MON and format
    const balanceInMon = formatEther(balance);
    walletBalance = parseFloat(balanceInMon).toFixed(4);
    
    console.log('Balance fetched:', walletBalance, 'MON');
    updateWalletUI();
  } catch (error) {
    console.error('Error fetching balance:', error);
    // Fallback to direct RPC call
    try {
      const balance = await window.ethereum.request({
        method: 'eth_getBalance',
        params: [walletAddress, 'latest']
      });
      const { formatEther } = window.viem;
      const balanceInMon = formatEther(BigInt(balance));
      walletBalance = parseFloat(balanceInMon).toFixed(4);
      updateWalletUI();
    } catch (fallbackError) {
      console.error('Fallback balance fetch failed:', fallbackError);
    }
  }
}

function updateWalletUI() {
  const walletBtn = document.getElementById('walletBtn');
  const balancePill = document.getElementById('balancePill');
  const balanceText = document.getElementById('balance');

  if (walletAddress) {
    // Show balance pill, hide connect button
    walletBtn.style.display = 'none';
    balancePill.style.display = 'flex';
    
    // Format address: 0x1234...5678
    const shortAddress = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
    balanceText.textContent = `${shortAddress} â€¢ ${walletBalance || '0.0000'} MON`;
  } else {
    // Show connect button, hide balance pill
    walletBtn.style.display = 'block';
    balancePill.style.display = 'none';
  }
}

function handleAccountsChanged(accounts) {
  if (accounts.length === 0) {
    // User disconnected wallet
    walletAddress = null;
    walletBalance = null;
    walletClient = null;
    publicClient = null;
    updateWalletUI();
  } else {
    // User switched accounts
    walletAddress = accounts[0];
    updateWalletBalance();
  }
}

function disconnectWallet() {
  walletAddress = null;
  walletBalance = null;
  walletClient = null;
  publicClient = null;
  updateWalletUI();
}

// ===== ANIMATION LOOP =====
function animate() {
  draw();
  requestAnimationFrame(animate);
}

// ===== INIT =====
async function initApp() {
  // Wait a bit for Pyth connection to be ready
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Fetch initial price from Pyth
  const success = await fetchPythPrice();
  
  if (success) {
    // Initialize price history with current price
    priceHistory = [currentPrice];
    openPrice = currentPrice;
    gridPriceHigh = currentPrice + 100;
    gridPriceLow = currentPrice - 100;
  }
  
  resize(); draw(); updateBetUI();
  document.getElementById('openPrice').textContent = '$' + openPrice.toFixed(0);
  document.getElementById('currentPrice').textContent = '$' + currentPrice.toFixed(2);
  
  // Start price updates
  setInterval(tick, 350);
  setInterval(timerTick, 1000);
  
  // Start continuous animation loop for smooth pulsing
  requestAnimationFrame(animate);
}

window.addEventListener('resize', () => { resize(); draw(); });

// Wallet button event listeners
document.getElementById('walletBtn').addEventListener('click', connectWallet);
document.getElementById('balancePill').addEventListener('click', disconnectWallet);

// Show connect button on load
updateWalletUI();

// Initialize app with real price data
initApp();
</script>
</body>
</html>
