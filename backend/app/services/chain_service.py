"""
chain_service.py
----------------
Async Web3 client for interacting with the $rush on-chain stack on Monad:
  - ConditionalTokens (CTF)  – ERC-1155 position tokens
  - MarketFactory            – market creation / resolution
  - CTFExchange              – on-chain CLOB settlement

ABIs here are minimal stubs covering only the functions the backend calls.
In production, load the full ABI from contracts/out/<Name>.sol/<Name>.json
(generated by `forge build`).
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from decimal import Decimal
from enum import IntEnum
from typing import Any

from eth_account import Account
from eth_account.messages import encode_defunct
from eth_typing import HexStr
from web3 import AsyncWeb3
from web3.contract import AsyncContract
from web3.middleware import ExtraDataToPOAMiddleware

from app.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# ---------------------------------------------------------------------------
# Minimal ABIs  (replace with full ABI once forge build output is available)
# ---------------------------------------------------------------------------

_CTF_ABI: list[dict] = [
    {
        "name": "balanceOf",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "account", "type": "address"}, {"name": "id", "type": "uint256"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "balanceOfBatch",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "accounts", "type": "address[]"}, {"name": "ids", "type": "uint256[]"}],
        "outputs": [{"name": "", "type": "uint256[]"}],
    },
    {
        "name": "isApprovedForAll",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "account", "type": "address"}, {"name": "operator", "type": "address"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "isResolved",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "payoutDenominator",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "payoutNumerators",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}, {"name": "index", "type": "uint256"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "getConditionId",
        "type": "function",
        "stateMutability": "pure",
        "inputs": [
            {"name": "oracle", "type": "address"},
            {"name": "questionId", "type": "bytes32"},
            {"name": "outcomeSlotCount", "type": "uint256"},
        ],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
    {
        "name": "getPositionIds",
        "type": "function",
        "stateMutability": "pure",
        "inputs": [
            {"name": "collateral", "type": "address"},
            {"name": "conditionId", "type": "bytes32"},
        ],
        "outputs": [
            {"name": "yesPositionId", "type": "uint256"},
            {"name": "noPositionId", "type": "uint256"},
        ],
    },
]

_FACTORY_ABI: list[dict] = [
    {
        "name": "getMarket",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [
            {
                "type": "tuple",
                "components": [
                    {"name": "questionId", "type": "bytes32"},
                    {"name": "conditionId", "type": "bytes32"},
                    {"name": "oracle", "type": "address"},
                    {"name": "collateralToken", "type": "address"},
                    {"name": "resolutionTime", "type": "uint256"},
                    {"name": "resolved", "type": "bool"},
                    {"name": "title", "type": "string"},
                    {"name": "description", "type": "string"},
                    {"name": "category", "type": "string"},
                ],
            }
        ],
    },
    {
        "name": "totalMarkets",
        "type": "function",
        "stateMutability": "view",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "getMarkets",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "offset", "type": "uint256"}, {"name": "limit", "type": "uint256"}],
        "outputs": [{"name": "result", "type": "bytes32[]"}],
    },
    {
        "name": "getPositionIds",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "yesId", "type": "uint256"}, {"name": "noId", "type": "uint256"}],
    },
    {
        "name": "createMarket",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {"name": "questionId", "type": "bytes32"},
            {"name": "oracle", "type": "address"},
            {"name": "collateralToken", "type": "address"},
            {"name": "resolutionTime", "type": "uint256"},
            {"name": "title", "type": "string"},
            {"name": "description", "type": "string"},
            {"name": "category", "type": "string"},
        ],
        "outputs": [{"name": "conditionId", "type": "bytes32"}],
    },
    {
        "name": "resolveMarket",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {"name": "conditionId", "type": "bytes32"},
            {"name": "payouts", "type": "uint256[]"},
        ],
        "outputs": [],
    },
]

_EXCHANGE_ABI: list[dict] = [
    {
        "name": "fillOrder",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            },
            {"name": "fillAmount", "type": "uint256"},
            {"name": "signature", "type": "bytes"},
        ],
        "outputs": [],
    },
    {
        "name": "fillOrders",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "orders",
                "type": "tuple[]",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            },
            {"name": "fillAmounts", "type": "uint256[]"},
            {"name": "signatures", "type": "bytes[]"},
        ],
        "outputs": [],
    },
    {
        "name": "cancelOrder",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            }
        ],
        "outputs": [],
    },
    {
        "name": "getOrderHash",
        "type": "function",
        "stateMutability": "view",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            }
        ],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
    {
        "name": "orderFills",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "orderHash", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "cancelledOrders",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "orderHash", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "domainSeparator",
        "type": "function",
        "stateMutability": "view",
        "inputs": [],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
    {
        "name": "owner",
        "type": "function",
        "stateMutability": "view",
        "inputs": [],
        "outputs": [{"name": "", "type": "address"}],
    },
    {
        "name": "operators",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "operator", "type": "address"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "setOperator",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {"name": "operator", "type": "address"},
            {"name": "approved", "type": "bool"},
        ],
        "outputs": [],
    },
]

# EIP-712 type string for off-chain hashing
ORDER_TYPE = {
    "Order": [
        {"name": "maker", "type": "address"},
        {"name": "tokenId", "type": "uint256"},
        {"name": "makerAmount", "type": "uint256"},
        {"name": "takerAmount", "type": "uint256"},
        {"name": "expiration", "type": "uint256"},
        {"name": "nonce", "type": "uint256"},
        {"name": "feeRateBps", "type": "uint256"},
        {"name": "side", "type": "uint8"},
        {"name": "signer", "type": "address"},
    ]
}


class OrderSide(IntEnum):
    BUY = 0
    SELL = 1


@dataclass
class ChainOrder:
    """Mirrors the Solidity Order struct."""
    maker: str
    token_id: int
    maker_amount: int
    taker_amount: int
    expiration: int
    nonce: int
    fee_rate_bps: int
    side: OrderSide
    signer: str = "0x0000000000000000000000000000000000000000"

    def to_tuple(self) -> tuple:
        return (
            self.maker,
            self.token_id,
            self.maker_amount,
            self.taker_amount,
            self.expiration,
            self.nonce,
            self.fee_rate_bps,
            int(self.side),
            self.signer,
        )


class ChainService:
    """
    Async Web3 interface for Monad + rush contracts.

    Usage (singleton per process):
        chain = ChainService()
        balance = await chain.get_position_balance(wallet, token_id)
    """

    def __init__(self) -> None:
        self.w3 = AsyncWeb3(AsyncWeb3.AsyncHTTPProvider(settings.MONAD_RPC_URL))
        # Monad may use POA consensus — add middleware if needed.
        # self.w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)

        self._operator: Account | None = (
            Account.from_key(settings.OPERATOR_PRIVATE_KEY)
            if settings.OPERATOR_PRIVATE_KEY
            else None
        )

        self.ctf: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.CTF_ADDRESS) if settings.CTF_ADDRESS else None,
            abi=_CTF_ABI,
        )
        self.factory: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.MARKET_FACTORY_ADDRESS) if settings.MARKET_FACTORY_ADDRESS else None,
            abi=_FACTORY_ABI,
        )
        self.exchange: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.CTF_EXCHANGE_ADDRESS) if settings.CTF_EXCHANGE_ADDRESS else None,
            abi=_EXCHANGE_ABI,
        )

    # -----------------------------------------------------------------------
    # Chain health
    # -----------------------------------------------------------------------

    async def is_connected(self) -> bool:
        try:
            await self.w3.eth.block_number
            return True
        except Exception:
            return False

    # -----------------------------------------------------------------------
    # ConditionalTokens read calls
    # -----------------------------------------------------------------------

    async def get_position_balance(self, wallet: str, token_id: int) -> int:
        """ERC-1155 balance of a CTF position token for a given wallet."""
        return await self.ctf.functions.balanceOf(
            AsyncWeb3.to_checksum_address(wallet), token_id
        ).call()

    async def get_position_balances(self, wallets: list[str], token_ids: list[int]) -> list[int]:
        """Batch ERC-1155 balance read."""
        checksummed = [AsyncWeb3.to_checksum_address(w) for w in wallets]
        return await self.ctf.functions.balanceOfBatch(checksummed, token_ids).call()

    async def is_market_resolved(self, condition_id: str) -> bool:
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        return await self.ctf.functions.isResolved(cid).call()

    async def get_payout_numerators(self, condition_id: str) -> tuple[int, int]:
        """Returns (yes_payout, no_payout) numerators for a resolved binary market."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        yes_payout = await self.ctf.functions.payoutNumerators(cid, 0).call()
        no_payout = await self.ctf.functions.payoutNumerators(cid, 1).call()
        return yes_payout, no_payout

    async def get_position_ids(self, condition_id: str) -> tuple[int, int]:
        """Get YES and NO token IDs for a market."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        yes_id, no_id = await self.factory.functions.getPositionIds(cid).call()
        return yes_id, no_id

    # -----------------------------------------------------------------------
    # MarketFactory read calls
    # -----------------------------------------------------------------------

    async def get_market(self, condition_id: str) -> dict:
        """Read full market struct from MarketFactory."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        result = await self.factory.functions.getMarket(cid).call()
        return {
            "question_id": "0x" + result[0].hex(),
            "condition_id": "0x" + result[1].hex(),
            "oracle": result[2],
            "collateral_token": result[3],
            "resolution_time": result[4],
            "resolved": result[5],
            "title": result[6],
            "description": result[7],
            "category": result[8],
        }

    async def get_market_count(self) -> int:
        return await self.factory.functions.totalMarkets().call()

    async def get_market_condition_ids(self, offset: int, limit: int) -> list[str]:
        raw = await self.factory.functions.getMarkets(offset, limit).call()
        return ["0x" + b.hex() for b in raw]

    # -----------------------------------------------------------------------
    # CTFExchange read calls
    # -----------------------------------------------------------------------

    async def get_order_fill(self, order_hash: str) -> int:
        h = bytes.fromhex(order_hash.lstrip("0x"))
        return await self.exchange.functions.orderFills(h).call()

    async def is_order_cancelled(self, order_hash: str) -> bool:
        h = bytes.fromhex(order_hash.lstrip("0x"))
        return await self.exchange.functions.cancelledOrders(h).call()

    async def get_order_hash(self, order: ChainOrder) -> str:
        h = await self.exchange.functions.getOrderHash(order.to_tuple()).call()
        return "0x" + h.hex()

    # -----------------------------------------------------------------------
    # CTFExchange write calls (operator-signed transactions)
    # -----------------------------------------------------------------------

    async def fill_order(
        self,
        order: ChainOrder,
        fill_amount: int,
        maker_signature: bytes,
    ) -> str:
        """
        Submit a single fillOrder() tx as the operator.
        Returns the transaction hash.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        tx = await self.exchange.functions.fillOrder(
            order.to_tuple(), fill_amount, maker_signature
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        # Estimate gas
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        logger.info("fillOrder tx sent: %s", tx_hash.hex())
        return tx_hash.hex()

    async def fill_orders_batch(
        self,
        orders: list[ChainOrder],
        fill_amounts: list[int],
        signatures: list[bytes],
    ) -> str:
        """
        Submit a batch fillOrders() tx as the operator.
        Used by the matching engine to settle multiple fills in one tx.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        order_tuples = [o.to_tuple() for o in orders]
        tx = await self.exchange.functions.fillOrders(
            order_tuples, fill_amounts, signatures
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        logger.info("fillOrders batch tx sent: %s", tx_hash.hex())
        return tx_hash.hex()

    async def cancel_order_onchain(self, order: ChainOrder) -> str:
        """Cancel an order on-chain (operator only, because the maker must call this
        — in practice the frontend calls it directly from the user's wallet)."""
        if not self._operator:
            raise RuntimeError("Operator private key not configured")
        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price
        tx = await self.exchange.functions.cancelOrder(order.to_tuple()).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)
        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()

    # -----------------------------------------------------------------------
    # MarketFactory write calls (operator-signed transactions)
    # -----------------------------------------------------------------------

    async def create_market_onchain(
        self,
        question_id: bytes,
        oracle: str,
        collateral_token: str,
        resolution_time: int,
        title: str,
        description: str,
        category: str,
    ) -> str:
        """
        Call MarketFactory.createMarket() as the operator (who must be the owner).
        Returns the 0x-prefixed hex conditionId emitted by the contract.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        tx = await self.factory.functions.createMarket(
            question_id,
            AsyncWeb3.to_checksum_address(oracle),
            AsyncWeb3.to_checksum_address(collateral_token),
            resolution_time,
            title,
            description,
            category,
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash)

        # The return value is the conditionId.  Decode it from the tx output.
        result = await self.factory.functions.createMarket(
            question_id,
            AsyncWeb3.to_checksum_address(oracle),
            AsyncWeb3.to_checksum_address(collateral_token),
            resolution_time,
            title,
            description,
            category,
        ).call({"from": self._operator.address})
        condition_id_hex = "0x" + result.hex()
        logger.info("createMarket tx %s → conditionId %s", tx_hash.hex(), condition_id_hex)
        return condition_id_hex

    async def resolve_market_onchain(self, condition_id_hex: str, payouts: list[int]) -> str:
        """
        Call MarketFactory.resolveMarket() as the operator (who must be the market oracle).
        Returns the transaction hash.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        cid = bytes.fromhex(condition_id_hex.lstrip("0x"))
        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        tx = await self.factory.functions.resolveMarket(
            cid, payouts
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        await self.w3.eth.wait_for_transaction_receipt(tx_hash)
        logger.info("resolveMarket tx %s conditionId %s", tx_hash.hex(), condition_id_hex)
        return tx_hash.hex()

    async def fill_orders(
        self,
        orders: list[ChainOrder],
        fill_amounts: list[int],
        signatures: list[str]
    ) -> str:
        """
        Call CTFExchange.fillOrders() to execute matched orders on-chain.
        
        Args:
            orders: List of ChainOrder objects to fill
            fill_amounts: Amount of tokens to fill for each order
            signatures: EIP-712 signatures for each order
            
        Returns:
            Transaction hash as hex string
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")
        
        print(f"DEBUG chain.fill_orders called with {len(orders)} orders, {len(fill_amounts)} amounts, {len(signatures)} sigs")
        if len(orders) != len(fill_amounts) or len(orders) != len(signatures):
            print(f"ERROR: Length mismatch!")
            raise ValueError("orders, fill_amounts, and signatures must have same length")
        
        print(f"DEBUG: Passed length check, starting order conversion...")
        logger.info(f"Filling {len(orders)} orders on-chain...")
        
        # Convert ChainOrder objects to tuples for contract call
        order_tuples = []
        for i, order in enumerate(orders):
            order_tuple = (
                AsyncWeb3.to_checksum_address(order.maker),
                order.token_id,
                order.maker_amount,
                order.taker_amount,
                order.expiration,
                order.nonce,
                order.fee_rate_bps,
                int(order.side),
                AsyncWeb3.to_checksum_address(order.signer)
            )
            order_tuples.append(order_tuple)
            print(f"DEBUG Order {i} tuple: {order_tuple}")
            logger.info(f"Order {i}: maker={order.maker}, tokenId={order.token_id}, side={order.side}")
            logger.info(f"  makerAmount={order.maker_amount}, takerAmount={order.taker_amount}")
            logger.info(f"  signer={order.signer}, sig={signatures[i][:20]}...")
        
        # Convert signatures to bytes
        sig_bytes = [bytes.fromhex(sig.lstrip("0x")) for sig in signatures]
        print(f"DEBUG: Converted {len(sig_bytes)} signatures to bytes")
        logger.info(f"Converted {len(sig_bytes)} signatures to bytes")
        
        # Build transaction
        print(f"DEBUG: Building transaction...")
        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price
        
        print(f"DEBUG: Calling fillOrders contract function...")
        tx = await self.exchange.functions.fillOrders(
            order_tuples,
            fill_amounts,
            sig_bytes
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        print(f"DEBUG: Transaction built successfully")
        
        # Estimate gas
        print(f"DEBUG: Estimating gas...")
        try:
            tx["gas"] = await self.w3.eth.estimate_gas(tx)
        except Exception as e:
            logger.error(f"Gas estimation failed: {e}")
            # Use a default gas limit if estimation fails
            tx["gas"] = 500000
        
        # Sign and send
        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        
        logger.info(f"fillOrders tx sent: {tx_hash.hex()}")
        
        # Wait for receipt
        receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        if receipt["status"] == 1:
            logger.info(f"✅ fillOrders successful: {tx_hash.hex()}")
        else:
            logger.error(f"❌ fillOrders failed: {tx_hash.hex()}")
            raise RuntimeError(f"Transaction failed: {tx_hash.hex()}")
        
        return tx_hash.hex()

    # -----------------------------------------------------------------------
    # EIP-712 helpers (off-chain)
    # -----------------------------------------------------------------------

    def build_eip712_message(self, order: ChainOrder) -> dict:
        """Build the EIP-712 structured data dict for client-side signing."""
        return {
            "domain": {
                "name": "CTFExchange",
                "version": "1",
                "chainId": settings.MONAD_CHAIN_ID,
                "verifyingContract": settings.CTF_EXCHANGE_ADDRESS,
            },
            "types": {"Order": ORDER_TYPE["Order"]},
            "primaryType": "Order",
            "message": {
                "maker": order.maker,
                "tokenId": order.token_id,
                "makerAmount": order.maker_amount,
                "takerAmount": order.taker_amount,
                "expiration": order.expiration,
                "nonce": order.nonce,
                "feeRateBps": order.fee_rate_bps,
                "side": int(order.side),
                "signer": order.signer,
            },
        }

    def recover_signer(self, order: ChainOrder, signature: str) -> str:
        """Recover the signer address from an EIP-712 order signature."""
        from eth_account.messages import encode_typed_data

        msg = self.build_eip712_message(order)
        # Build domain separator and encode
        structured_msg = encode_typed_data(full_message=msg)
        recovered = Account.recover_message(structured_msg, signature=signature)
        return recovered


# Singleton — import this everywhere instead of constructing per-request.
chain: ChainService = ChainService()
