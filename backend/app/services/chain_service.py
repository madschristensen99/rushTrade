"""
chain_service.py
----------------
Async Web3 client for interacting with the $rush on-chain stack on Monad:
  - ConditionalTokens (CTF)  – ERC-1155 position tokens
  - MarketFactory            – market creation / resolution
  - CTFExchange              – on-chain CLOB settlement

ABIs here are minimal stubs covering only the functions the backend calls.
In production, load the full ABI from contracts/out/<Name>.sol/<Name>.json
(generated by `forge build`).
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from decimal import Decimal
from enum import IntEnum
from typing import Any

from eth_account import Account
from eth_account.messages import encode_defunct
from eth_typing import HexStr
from web3 import AsyncWeb3
from web3.contract import AsyncContract
from web3.middleware import ExtraDataToPOAMiddleware

from app.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# ---------------------------------------------------------------------------
# Minimal ABIs  (replace with full ABI once forge build output is available)
# ---------------------------------------------------------------------------

_CTF_ABI: list[dict] = [
    {
        "name": "balanceOf",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "account", "type": "address"}, {"name": "id", "type": "uint256"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "balanceOfBatch",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "accounts", "type": "address[]"}, {"name": "ids", "type": "uint256[]"}],
        "outputs": [{"name": "", "type": "uint256[]"}],
    },
    {
        "name": "isApprovedForAll",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "account", "type": "address"}, {"name": "operator", "type": "address"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "isResolved",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "payoutDenominator",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "payoutNumerators",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}, {"name": "index", "type": "uint256"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "getConditionId",
        "type": "function",
        "stateMutability": "pure",
        "inputs": [
            {"name": "oracle", "type": "address"},
            {"name": "questionId", "type": "bytes32"},
            {"name": "outcomeSlotCount", "type": "uint256"},
        ],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
    {
        "name": "getPositionIds",
        "type": "function",
        "stateMutability": "pure",
        "inputs": [
            {"name": "collateral", "type": "address"},
            {"name": "conditionId", "type": "bytes32"},
        ],
        "outputs": [
            {"name": "yesPositionId", "type": "uint256"},
            {"name": "noPositionId", "type": "uint256"},
        ],
    },
]

_FACTORY_ABI: list[dict] = [
    {
        "name": "getMarket",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [
            {
                "type": "tuple",
                "components": [
                    {"name": "questionId", "type": "bytes32"},
                    {"name": "conditionId", "type": "bytes32"},
                    {"name": "oracle", "type": "address"},
                    {"name": "collateralToken", "type": "address"},
                    {"name": "resolutionTime", "type": "uint256"},
                    {"name": "resolved", "type": "bool"},
                    {"name": "title", "type": "string"},
                    {"name": "description", "type": "string"},
                    {"name": "category", "type": "string"},
                ],
            }
        ],
    },
    {
        "name": "totalMarkets",
        "type": "function",
        "stateMutability": "view",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "getMarkets",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "offset", "type": "uint256"}, {"name": "limit", "type": "uint256"}],
        "outputs": [{"name": "result", "type": "bytes32[]"}],
    },
    {
        "name": "getPositionIds",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "conditionId", "type": "bytes32"}],
        "outputs": [{"name": "yesId", "type": "uint256"}, {"name": "noId", "type": "uint256"}],
    },
]

_EXCHANGE_ABI: list[dict] = [
    {
        "name": "fillOrder",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            },
            {"name": "fillAmount", "type": "uint256"},
            {"name": "signature", "type": "bytes"},
        ],
        "outputs": [],
    },
    {
        "name": "fillOrders",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "orders",
                "type": "tuple[]",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            },
            {"name": "fillAmounts", "type": "uint256[]"},
            {"name": "signatures", "type": "bytes[]"},
        ],
        "outputs": [],
    },
    {
        "name": "cancelOrder",
        "type": "function",
        "stateMutability": "nonpayable",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            }
        ],
        "outputs": [],
    },
    {
        "name": "getOrderHash",
        "type": "function",
        "stateMutability": "view",
        "inputs": [
            {
                "name": "order",
                "type": "tuple",
                "components": [
                    {"name": "maker", "type": "address"},
                    {"name": "tokenId", "type": "uint256"},
                    {"name": "makerAmount", "type": "uint256"},
                    {"name": "takerAmount", "type": "uint256"},
                    {"name": "expiration", "type": "uint256"},
                    {"name": "nonce", "type": "uint256"},
                    {"name": "feeRateBps", "type": "uint256"},
                    {"name": "side", "type": "uint8"},
                    {"name": "signer", "type": "address"},
                ],
            }
        ],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
    {
        "name": "orderFills",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "orderHash", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "uint256"}],
    },
    {
        "name": "cancelledOrders",
        "type": "function",
        "stateMutability": "view",
        "inputs": [{"name": "orderHash", "type": "bytes32"}],
        "outputs": [{"name": "", "type": "bool"}],
    },
    {
        "name": "domainSeparator",
        "type": "function",
        "stateMutability": "view",
        "inputs": [],
        "outputs": [{"name": "", "type": "bytes32"}],
    },
]

# EIP-712 type string for off-chain hashing
ORDER_TYPE = {
    "Order": [
        {"name": "maker", "type": "address"},
        {"name": "tokenId", "type": "uint256"},
        {"name": "makerAmount", "type": "uint256"},
        {"name": "takerAmount", "type": "uint256"},
        {"name": "expiration", "type": "uint256"},
        {"name": "nonce", "type": "uint256"},
        {"name": "feeRateBps", "type": "uint256"},
        {"name": "side", "type": "uint8"},
        {"name": "signer", "type": "address"},
    ]
}


class OrderSide(IntEnum):
    BUY = 0
    SELL = 1


@dataclass
class ChainOrder:
    """Mirrors the Solidity Order struct."""
    maker: str
    token_id: int
    maker_amount: int
    taker_amount: int
    expiration: int
    nonce: int
    fee_rate_bps: int
    side: OrderSide
    signer: str = "0x0000000000000000000000000000000000000000"

    def to_tuple(self) -> tuple:
        return (
            self.maker,
            self.token_id,
            self.maker_amount,
            self.taker_amount,
            self.expiration,
            self.nonce,
            self.fee_rate_bps,
            int(self.side),
            self.signer,
        )


class ChainService:
    """
    Async Web3 interface for Monad + rush contracts.

    Usage (singleton per process):
        chain = ChainService()
        balance = await chain.get_position_balance(wallet, token_id)
    """

    def __init__(self) -> None:
        self.w3 = AsyncWeb3(AsyncWeb3.AsyncHTTPProvider(settings.MONAD_RPC_URL))
        # Monad may use POA consensus — add middleware if needed.
        # self.w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)

        self._operator: Account | None = (
            Account.from_key(settings.OPERATOR_PRIVATE_KEY)
            if settings.OPERATOR_PRIVATE_KEY
            else None
        )

        self.ctf: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.CTF_ADDRESS) if settings.CTF_ADDRESS else None,
            abi=_CTF_ABI,
        )
        self.factory: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.MARKET_FACTORY_ADDRESS) if settings.MARKET_FACTORY_ADDRESS else None,
            abi=_FACTORY_ABI,
        )
        self.exchange: AsyncContract = self.w3.eth.contract(
            address=AsyncWeb3.to_checksum_address(settings.CTF_EXCHANGE_ADDRESS) if settings.CTF_EXCHANGE_ADDRESS else None,
            abi=_EXCHANGE_ABI,
        )

    # -----------------------------------------------------------------------
    # Chain health
    # -----------------------------------------------------------------------

    async def is_connected(self) -> bool:
        try:
            await self.w3.eth.block_number
            return True
        except Exception:
            return False

    # -----------------------------------------------------------------------
    # ConditionalTokens read calls
    # -----------------------------------------------------------------------

    async def get_position_balance(self, wallet: str, token_id: int) -> int:
        """ERC-1155 balance of a CTF position token for a given wallet."""
        return await self.ctf.functions.balanceOf(
            AsyncWeb3.to_checksum_address(wallet), token_id
        ).call()

    async def get_position_balances(self, wallets: list[str], token_ids: list[int]) -> list[int]:
        """Batch ERC-1155 balance read."""
        checksummed = [AsyncWeb3.to_checksum_address(w) for w in wallets]
        return await self.ctf.functions.balanceOfBatch(checksummed, token_ids).call()

    async def is_market_resolved(self, condition_id: str) -> bool:
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        return await self.ctf.functions.isResolved(cid).call()

    async def get_payout_numerators(self, condition_id: str) -> tuple[int, int]:
        """Returns (yes_payout, no_payout) numerators for a resolved binary market."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        yes_payout = await self.ctf.functions.payoutNumerators(cid, 0).call()
        no_payout = await self.ctf.functions.payoutNumerators(cid, 1).call()
        return yes_payout, no_payout

    async def get_position_ids(self, condition_id: str) -> tuple[int, int]:
        """Get YES and NO token IDs for a market."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        yes_id, no_id = await self.factory.functions.getPositionIds(cid).call()
        return yes_id, no_id

    # -----------------------------------------------------------------------
    # MarketFactory read calls
    # -----------------------------------------------------------------------

    async def get_market(self, condition_id: str) -> dict:
        """Read full market struct from MarketFactory."""
        cid = bytes.fromhex(condition_id.lstrip("0x"))
        result = await self.factory.functions.getMarket(cid).call()
        return {
            "question_id": "0x" + result[0].hex(),
            "condition_id": "0x" + result[1].hex(),
            "oracle": result[2],
            "collateral_token": result[3],
            "resolution_time": result[4],
            "resolved": result[5],
            "title": result[6],
            "description": result[7],
            "category": result[8],
        }

    async def get_market_count(self) -> int:
        return await self.factory.functions.totalMarkets().call()

    async def get_market_condition_ids(self, offset: int, limit: int) -> list[str]:
        raw = await self.factory.functions.getMarkets(offset, limit).call()
        return ["0x" + b.hex() for b in raw]

    # -----------------------------------------------------------------------
    # CTFExchange read calls
    # -----------------------------------------------------------------------

    async def get_order_fill(self, order_hash: str) -> int:
        h = bytes.fromhex(order_hash.lstrip("0x"))
        return await self.exchange.functions.orderFills(h).call()

    async def is_order_cancelled(self, order_hash: str) -> bool:
        h = bytes.fromhex(order_hash.lstrip("0x"))
        return await self.exchange.functions.cancelledOrders(h).call()

    async def get_order_hash(self, order: ChainOrder) -> str:
        h = await self.exchange.functions.getOrderHash(order.to_tuple()).call()
        return "0x" + h.hex()

    # -----------------------------------------------------------------------
    # CTFExchange write calls (operator-signed transactions)
    # -----------------------------------------------------------------------

    async def fill_order(
        self,
        order: ChainOrder,
        fill_amount: int,
        maker_signature: bytes,
    ) -> str:
        """
        Submit a single fillOrder() tx as the operator.
        Returns the transaction hash.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        tx = await self.exchange.functions.fillOrder(
            order.to_tuple(), fill_amount, maker_signature
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        # Estimate gas
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        logger.info("fillOrder tx sent: %s", tx_hash.hex())
        return tx_hash.hex()

    async def fill_orders_batch(
        self,
        orders: list[ChainOrder],
        fill_amounts: list[int],
        signatures: list[bytes],
    ) -> str:
        """
        Submit a batch fillOrders() tx as the operator.
        Used by the matching engine to settle multiple fills in one tx.
        """
        if not self._operator:
            raise RuntimeError("Operator private key not configured")

        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price

        order_tuples = [o.to_tuple() for o in orders]
        tx = await self.exchange.functions.fillOrders(
            order_tuples, fill_amounts, signatures
        ).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)

        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        logger.info("fillOrders batch tx sent: %s", tx_hash.hex())
        return tx_hash.hex()

    async def cancel_order_onchain(self, order: ChainOrder) -> str:
        """Cancel an order on-chain (operator only, because the maker must call this
        — in practice the frontend calls it directly from the user's wallet)."""
        if not self._operator:
            raise RuntimeError("Operator private key not configured")
        nonce = await self.w3.eth.get_transaction_count(self._operator.address)
        gas_price = await self.w3.eth.gas_price
        tx = await self.exchange.functions.cancelOrder(order.to_tuple()).build_transaction(
            {
                "from": self._operator.address,
                "nonce": nonce,
                "gasPrice": gas_price,
                "chainId": settings.MONAD_CHAIN_ID,
            }
        )
        tx["gas"] = await self.w3.eth.estimate_gas(tx)
        signed = self._operator.sign_transaction(tx)
        tx_hash = await self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()

    # -----------------------------------------------------------------------
    # EIP-712 helpers (off-chain)
    # -----------------------------------------------------------------------

    def build_eip712_message(self, order: ChainOrder) -> dict:
        """Build the EIP-712 structured data dict for client-side signing."""
        return {
            "domain": {
                "name": "CTFExchange",
                "version": "1",
                "chainId": settings.MONAD_CHAIN_ID,
                "verifyingContract": settings.CTF_EXCHANGE_ADDRESS,
            },
            "types": {"Order": ORDER_TYPE["Order"]},
            "primaryType": "Order",
            "message": {
                "maker": order.maker,
                "tokenId": order.token_id,
                "makerAmount": order.maker_amount,
                "takerAmount": order.taker_amount,
                "expiration": order.expiration,
                "nonce": order.nonce,
                "feeRateBps": order.fee_rate_bps,
                "side": int(order.side),
                "signer": order.signer,
            },
        }

    def recover_signer(self, order: ChainOrder, signature: str) -> str:
        """Recover the signer address from an EIP-712 order signature."""
        from eth_account.messages import encode_typed_data

        msg = self.build_eip712_message(order)
        # Build domain separator and encode
        structured_msg = encode_typed_data(full_message=msg)
        recovered = Account.recover_message(structured_msg, signature=signature)
        return recovered


# Singleton — import this everywhere instead of constructing per-request.
chain: ChainService = ChainService()
